package commands

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/l3montree-dev/devguard/dtos/sarif"
	"github.com/l3montree-dev/devguard/utils"
	"github.com/spf13/cobra"
)

type kyvernoTestResult struct {
	ID       int    `json:"ID"`
	Policy   string `json:"POLICY"`
	Reason   string `json:"REASON"`
	Resource string `json:"RESOURCE"`
	Result   string `json:"RESULT"`
	Rule     string `json:"RULE"`
}

func newKyvernoSarifCommand() *cobra.Command {
	cmd := &cobra.Command{
		Use:               "kyverno2sarif",
		Short:             "Convert Kyverno test output to SARIF",
		DisableAutoGenTag: true,
		Long:              `Converts JSON output generated by the kyverno test command into SARIF format.`,
		Example: `  # Convert Kyverno output to SARIF
  devguard-scanner kyverno2sarif -i kyverno-results.json

  # Save to file
  devguard-scanner kyverno2sarif -i kyverno-results.json -o sarif.json`,
		RunE: func(cmd *cobra.Command, args []string) error {
			inputPath, _ := cmd.Flags().GetString("input")
			outputPath, _ := cmd.Flags().GetString("output")

			if inputPath == "" {
				return fmt.Errorf("input file is required")
			}

			data, err := os.ReadFile(inputPath)
			if err != nil {
				return fmt.Errorf("error reading input file: %w", err)
			}

			jsonData, err := extractKyvernoJSON(string(data))
			if err != nil {
				return fmt.Errorf("error extracting JSON: %w", err)
			}

			var kyvernoResults []kyvernoTestResult
			if err := json.Unmarshal([]byte(jsonData), &kyvernoResults); err != nil {
				return fmt.Errorf("error parsing JSON: %w", err)
			}

			sarif := convertKyvernoToSARIF(kyvernoResults)

			sarifJSON, err := json.MarshalIndent(sarif, "", "  ")
			if err != nil {
				return fmt.Errorf("error generating SARIF JSON: %w", err)
			}

			if outputPath == "" {
				fmt.Println(string(sarifJSON))
				return nil
			}

			if err := os.WriteFile(outputPath, sarifJSON, 0o644); err != nil {
				return fmt.Errorf("error writing output file: %w", err)
			}
			return nil
		},
	}

	cmd.Flags().StringP("input", "i", "", "Input file containing Kyverno test output (must be json format)")
	cmd.Flags().StringP("output", "o", "", "Output SARIF file (default: stdout)")
	cmd.MarkFlagRequired("input") //nolint:errcheck

	return cmd
}

func extractKyvernoJSON(content string) (string, error) {
	start := strings.Index(content, "[")
	if start == -1 {
		return "", fmt.Errorf("no JSON array found in input")
	}

	end := strings.LastIndex(content, "]")
	if end == -1 || end < start {
		return "", fmt.Errorf("malformed JSON array in input")
	}

	return content[start : end+1], nil
}

func convertKyvernoToSARIF(kyvernoResults []kyvernoTestResult) sarif.SarifSchema210Json {
	rulesMap := make(map[string]sarif.ReportingDescriptor)
	var results []sarif.Result

	for _, kr := range kyvernoResults {
		ruleID := fmt.Sprintf("%s/%s", kr.Policy, kr.Rule)

		if _, exists := rulesMap[ruleID]; !exists {
			rulesMap[ruleID] = sarif.ReportingDescriptor{
				ID:   ruleID,
				Name: &kr.Rule,
				ShortDescription: &sarif.MultiformatMessageString{
					Text: fmt.Sprintf("%s - %s", kr.Policy, kr.Rule),
				},
				FullDescription: &sarif.MultiformatMessageString{
					Text: fmt.Sprintf("Kyverno policy '%s' rule '%s'", kr.Policy, kr.Rule),
				},
				Properties: &sarif.PropertyBag{
					Tags: []string{"kyverno", "security", "kubernetes"},
				},
			}
		}

		if kr.Result == "Pass" {
			continue
		}

		result := sarif.Result{
			RuleID: &ruleID,
			Level:  sarif.ResultLevelWarning,
			Message: sarif.Message{
				Text: fmt.Sprintf("%s (Resource: %s)", kr.Reason, kr.Resource),
			},
			Properties: &sarif.PropertyBag{
				AdditionalProperties: map[string]any{
					"kyvernoId": kr.ID,
					"resource":  kr.Resource,
					"policy":    kr.Policy,
				},
			},
		}

		if kr.Resource != "" {
			parts := strings.Split(kr.Resource, "/")
			resourceName := kr.Resource
			if len(parts) > 0 {
				resourceName = parts[len(parts)-1]
			}

			result.Locations = []sarif.Location{
				{
					LogicalLocations: []sarif.LogicalLocation{
						{
							Name: &resourceName,
							Kind: utils.Ptr("resource"),
						},
					},
				},
			}
		}

		results = append(results, result)
	}

	var rules []sarif.ReportingDescriptor
	for _, rule := range rulesMap {
		rules = append(rules, rule)
	}

	return sarif.SarifSchema210Json{
		Version: "2.1.0",
		Schema:  utils.Ptr("https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json"),
		Runs: []sarif.Run{
			{
				Tool: sarif.Tool{
					Driver: sarif.ToolComponent{
						Name:            "Kyverno",
						InformationURI:  utils.Ptr("https://kyverno.io/"),
						Version:         utils.Ptr("1.0.0"),
						SemanticVersion: utils.Ptr("1.0.0"),
						Rules:           rules,
					},
				},
				Results: results,
			},
		},
	}
}
