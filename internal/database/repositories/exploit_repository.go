// Copyright (C) 2024 Tim Bastin, l3montree UG (haftungsbeschr√§nkt)
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package repositories

import (
	"fmt"
	"log/slog"
	"os"

	"github.com/google/uuid"
	"github.com/l3montree-dev/devguard/internal/common"
	"github.com/l3montree-dev/devguard/internal/core"
	"github.com/l3montree-dev/devguard/internal/database/models"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/logger"
)

type exploitRepository struct {
	db core.DB
	common.Repository[uuid.UUID, models.Exploit, core.DB]
}

func NewExploitRepository(db core.DB) *exploitRepository {
	if os.Getenv("DISABLE_AUTOMIGRATE") != "true" {
		if err := db.AutoMigrate(&models.Exploit{}); err != nil {
			panic(err)
		}
	}
	return &exploitRepository{
		db:         db,
		Repository: newGormRepository[uuid.UUID, models.Exploit](db),
	}
}
func (g *exploitRepository) GetAllExploitsID() ([]string, error) {
	var exploitsID []string
	batchSize := 10000
	offset := 0

	for {
		var batch []string
		err := g.db.Model(&models.Exploit{}).
			Offset(offset).
			Limit(batchSize).
			Pluck("id", &batch).
			Error
		if err != nil {
			return nil, err
		}

		if len(batch) == 0 {
			break
		}

		exploitsID = append(exploitsID, batch...)
		offset += batchSize
	}

	return exploitsID, nil
}
func (g *exploitRepository) createInBatches(tx core.DB, exploits []models.Exploit, batchSize int) error {
	// Collect all CVE IDs from the exploits
	var cveIDs []string
	for _, exploit := range exploits {
		cveIDs = append(cveIDs, exploit.CVEID)
	}

	// Query to find valid CVE IDs
	var validCveIDs []string
	if err := g.GetDB(tx).Model(&models.CVE{}).Where("cve IN ?", cveIDs).Pluck("cve", &validCveIDs).Error; err != nil {
		return fmt.Errorf("error fetching valid CVE IDs: %w", err)
	}

	// Create a map for quick lookup of valid CVE IDs
	validCveIDMap := make(map[string]struct{})
	for _, id := range validCveIDs {
		validCveIDMap[id] = struct{}{}
	}

	// Filter out exploits with invalid CVE IDs
	var validExploits []models.Exploit
	invalidCodes := make([]string, 0)
	for _, exploit := range exploits {
		if _, exists := validCveIDMap[exploit.CVEID]; exists {
			validExploits = append(validExploits, exploit)
		} else {
			invalidCodes = append(invalidCodes, exploit.CVEID)
		}
	}

	// save the invalid codes in a json file
	if len(invalidCodes) > 0 {
		slog.Warn("could not find CVE IDs", "ids", invalidCodes)
	}

	if len(validExploits) == 0 {
		slog.Warn("no valid exploits to insert")
		return nil
	}

	err := g.GetDB(tx).Session(
		&gorm.Session{
			Logger: logger.Default.LogMode(logger.Silent),
		}).Clauses(
		clause.OnConflict{
			UpdateAll: true,
		},
	).CreateInBatches(&validExploits, batchSize).Error

	// Check if we got a protocol error since we are inserting more than 65535 parameters
	if err != nil && err.Error() == "extended protocol limited to 65535 parameters; extended protocol limited to 65535 parameters" {
		newBatchSize := batchSize / 2
		if newBatchSize < 1 {
			// We can't reduce the batch size anymore
			// Let's try to save the CVEs one by one
			// This will be slow but it will work
			for _, exploit := range validExploits {
				tmpPkg := exploit
				if err := g.GetDB(tx).Session(
					&gorm.Session{
						// Logger: logger.Default.LogMode(logger.Silent),
					}).Clauses(
					clause.OnConflict{
						UpdateAll: true,
					},
				).Create(&tmpPkg).Error; err != nil {
					// Log that we weren't able to save the CVE
					slog.Error("unable to save exploit", "exploit", exploit.CVEID, "err", err)
				}
			}
			return nil
		}
		slog.Warn("protocol error, trying to reduce batch size", "newBatchSize", newBatchSize, "oldBatchSize", batchSize, "err", err)
		return g.createInBatches(tx, validExploits, newBatchSize)
	}

	return err
}

func (g *exploitRepository) SaveBatch(tx core.DB, exploits []models.Exploit) error {
	return g.createInBatches(tx, exploits, 1000)
}
