package repositories

import (
	"fmt"

	"github.com/google/uuid"
	"github.com/l3montree-dev/devguard/internal/common"
	"github.com/l3montree-dev/devguard/internal/core"

	"github.com/l3montree-dev/devguard/internal/database/models"
	"gorm.io/gorm"
)

type AggregatedVulnRepository struct {
	firstPartyVulnerabilityRepository firstPartyVulnerabilityRepository
	dependencyVulnRepository          dependencyVulnRepository
}

func NewAggregatedVulnRepository(db core.DB) *AggregatedVulnRepository {
	return &AggregatedVulnRepository{
		firstPartyVulnerabilityRepository: firstPartyVulnerabilityRepository{
			db:                      db,
			VulnerabilityRepository: *NewVulnerabilityRepository[models.FirstPartyVuln](db),
		},
		dependencyVulnRepository: dependencyVulnRepository{
			db:                      db,
			VulnerabilityRepository: *NewVulnerabilityRepository[models.DependencyVuln](db),
		},
	}
}

func (a AggregatedVulnRepository) Transaction(txFunc func(tx core.DB) error) error {
	return a.firstPartyVulnerabilityRepository.Transaction(txFunc)
}

func (a AggregatedVulnRepository) Save(tx core.DB, vuln *models.Vuln) error {
	if vuln == nil {
		return fmt.Errorf("vuln is nil")
	}

	if fpv, ok := (*vuln).(*models.FirstPartyVuln); ok {
		return a.firstPartyVulnerabilityRepository.Save(tx, fpv)
	}
	if dv, ok := (*vuln).(*models.DependencyVuln); ok {
		return a.dependencyVulnRepository.Save(tx, dv)
	}
	return fmt.Errorf("unknown vulnerability type")
}

func (a AggregatedVulnRepository) FindByTicketID(tx core.DB, ticketID string) (models.Vuln, error) {
	firstPartyVuln, err := a.firstPartyVulnerabilityRepository.FindByTicketID(tx, ticketID)
	if err != nil {
		// maybe a dependency vuln
		dependencyVuln, err := a.dependencyVulnRepository.FindByTicketID(tx, ticketID)
		if err != nil {
			return nil, err
		}
		return &dependencyVuln, nil
	}
	return &firstPartyVuln, nil
}

func (a AggregatedVulnRepository) GetOrgFromVuln(vuln models.Vuln) (models.Org, error) {
	if _, ok := vuln.(*models.FirstPartyVuln); ok {
		return a.firstPartyVulnerabilityRepository.GetOrgFromVulnID(nil, vuln.GetID())
	}
	return a.dependencyVulnRepository.GetOrgFromVulnID(nil, vuln.GetID())
}

func (a AggregatedVulnRepository) ApplyAndSave(
	tx core.DB,
	vuln models.Vuln,
	vulnEvent *models.VulnEvent,
) error {
	if vuln == nil {
		return fmt.Errorf("vuln is nil")
	}

	if fpv, ok := (vuln).(*models.FirstPartyVuln); ok {
		return a.firstPartyVulnerabilityRepository.ApplyAndSave(tx, fpv, vulnEvent)
	}
	if dv, ok := (vuln).(*models.DependencyVuln); ok {
		return a.dependencyVulnRepository.ApplyAndSave(tx, dv, vulnEvent)
	}
	return fmt.Errorf("unknown vulnerability type")
}

type VulnStats struct {
	TotalRisk           float64 `json:"total_risk"`
	AvgRisk             float64 `json:"avg_risk"`
	MaxRisk             float64 `json:"max_risk"`
	DependencyVulnCount int64   `json:"dependencyVuln_count"`
	PackageName         string  `json:"package_name"`
}

type VulnerabilityRepository[T common.Tabler] struct {
	db core.DB
	common.Repository[string, T, core.DB]
}

func NewVulnerabilityRepository[T common.Tabler](db core.DB) *VulnerabilityRepository[T] {
	return &VulnerabilityRepository[T]{
		db:         db,
		Repository: newGormRepository[string, T](db),
	}
}

func (r *VulnerabilityRepository[T]) GetByAssetId(
	tx *gorm.DB,
	assetId uuid.UUID,
) ([]T, error) {

	var vulns = []T{}
	// get all vulnerabilities of the asset
	if err := r.Repository.GetDB(tx).Where("asset_id = ?", assetId).Find(&vulns).Error; err != nil {
		return nil, err
	}
	return vulns, nil
}

func (r *VulnerabilityRepository[T]) GetAllVulnsByAssetID(tx core.DB, assetID uuid.UUID) ([]T, error) {
	var vulns = []T{}
	if err := r.Repository.GetDB(tx).Preload("CVE").Where("asset_id = ?", assetID).Find(&vulns).Error; err != nil {
		return nil, err
	}
	return vulns, nil
}

func (r *VulnerabilityRepository[T]) GetAllOpenVulnsByAssetVersionNameAndAssetId(tx core.DB, assetVersionName string, assetID uuid.UUID) ([]T, error) {
	var vulns = []T{}
	if err := r.Repository.GetDB(tx).Where("asset_version_name = ? AND asset_id = ? AND state = ?", assetVersionName, assetID, models.VulnStateOpen).Find(&vulns).Error; err != nil {
		return nil, err
	}
	return vulns, nil
}

func (r *VulnerabilityRepository[T]) FindByTicketID(tx core.DB, ticketID string) (T, error) {
	var vuln T
	if err := r.Repository.GetDB(tx).Where("ticket_id = ?", ticketID).First(&vuln).Error; err != nil {
		return vuln, err
	}
	return vuln, nil
}
