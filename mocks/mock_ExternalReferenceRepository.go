// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"github.com/google/uuid"
	"github.com/l3montree-dev/devguard/database/models"
	mock "github.com/stretchr/testify/mock"
	"gorm.io/gorm"
)

// NewExternalReferenceRepository creates a new instance of ExternalReferenceRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExternalReferenceRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExternalReferenceRepository {
	mock := &ExternalReferenceRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ExternalReferenceRepository is an autogenerated mock type for the ExternalReferenceRepository type
type ExternalReferenceRepository struct {
	mock.Mock
}

type ExternalReferenceRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *ExternalReferenceRepository) EXPECT() *ExternalReferenceRepository_Expecter {
	return &ExternalReferenceRepository_Expecter{mock: &_m.Mock}
}

// Create provides a mock function for the type ExternalReferenceRepository
func (_mock *ExternalReferenceRepository) Create(db *gorm.DB, ref *models.ExternalReference) error {
	ret := _mock.Called(db, ref)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*gorm.DB, *models.ExternalReference) error); ok {
		r0 = returnFunc(db, ref)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExternalReferenceRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type ExternalReferenceRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - db *gorm.DB
//   - ref *models.ExternalReference
func (_e *ExternalReferenceRepository_Expecter) Create(db interface{}, ref interface{}) *ExternalReferenceRepository_Create_Call {
	return &ExternalReferenceRepository_Create_Call{Call: _e.mock.On("Create", db, ref)}
}

func (_c *ExternalReferenceRepository_Create_Call) Run(run func(db *gorm.DB, ref *models.ExternalReference)) *ExternalReferenceRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *gorm.DB
		if args[0] != nil {
			arg0 = args[0].(*gorm.DB)
		}
		var arg1 *models.ExternalReference
		if args[1] != nil {
			arg1 = args[1].(*models.ExternalReference)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExternalReferenceRepository_Create_Call) Return(err error) *ExternalReferenceRepository_Create_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExternalReferenceRepository_Create_Call) RunAndReturn(run func(db *gorm.DB, ref *models.ExternalReference) error) *ExternalReferenceRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// CreateBatch provides a mock function for the type ExternalReferenceRepository
func (_mock *ExternalReferenceRepository) CreateBatch(db *gorm.DB, refs []models.ExternalReference) error {
	ret := _mock.Called(db, refs)

	if len(ret) == 0 {
		panic("no return value specified for CreateBatch")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*gorm.DB, []models.ExternalReference) error); ok {
		r0 = returnFunc(db, refs)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExternalReferenceRepository_CreateBatch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateBatch'
type ExternalReferenceRepository_CreateBatch_Call struct {
	*mock.Call
}

// CreateBatch is a helper method to define mock.On call
//   - db *gorm.DB
//   - refs []models.ExternalReference
func (_e *ExternalReferenceRepository_Expecter) CreateBatch(db interface{}, refs interface{}) *ExternalReferenceRepository_CreateBatch_Call {
	return &ExternalReferenceRepository_CreateBatch_Call{Call: _e.mock.On("CreateBatch", db, refs)}
}

func (_c *ExternalReferenceRepository_CreateBatch_Call) Run(run func(db *gorm.DB, refs []models.ExternalReference)) *ExternalReferenceRepository_CreateBatch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *gorm.DB
		if args[0] != nil {
			arg0 = args[0].(*gorm.DB)
		}
		var arg1 []models.ExternalReference
		if args[1] != nil {
			arg1 = args[1].([]models.ExternalReference)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExternalReferenceRepository_CreateBatch_Call) Return(err error) *ExternalReferenceRepository_CreateBatch_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExternalReferenceRepository_CreateBatch_Call) RunAndReturn(run func(db *gorm.DB, refs []models.ExternalReference) error) *ExternalReferenceRepository_CreateBatch_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteByAssetVersion provides a mock function for the type ExternalReferenceRepository
func (_mock *ExternalReferenceRepository) DeleteByAssetVersion(db *gorm.DB, assetID uuid.UUID, assetVersionName string) error {
	ret := _mock.Called(db, assetID, assetVersionName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteByAssetVersion")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(*gorm.DB, uuid.UUID, string) error); ok {
		r0 = returnFunc(db, assetID, assetVersionName)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// ExternalReferenceRepository_DeleteByAssetVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteByAssetVersion'
type ExternalReferenceRepository_DeleteByAssetVersion_Call struct {
	*mock.Call
}

// DeleteByAssetVersion is a helper method to define mock.On call
//   - db *gorm.DB
//   - assetID uuid.UUID
//   - assetVersionName string
func (_e *ExternalReferenceRepository_Expecter) DeleteByAssetVersion(db interface{}, assetID interface{}, assetVersionName interface{}) *ExternalReferenceRepository_DeleteByAssetVersion_Call {
	return &ExternalReferenceRepository_DeleteByAssetVersion_Call{Call: _e.mock.On("DeleteByAssetVersion", db, assetID, assetVersionName)}
}

func (_c *ExternalReferenceRepository_DeleteByAssetVersion_Call) Run(run func(db *gorm.DB, assetID uuid.UUID, assetVersionName string)) *ExternalReferenceRepository_DeleteByAssetVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *gorm.DB
		if args[0] != nil {
			arg0 = args[0].(*gorm.DB)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ExternalReferenceRepository_DeleteByAssetVersion_Call) Return(err error) *ExternalReferenceRepository_DeleteByAssetVersion_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *ExternalReferenceRepository_DeleteByAssetVersion_Call) RunAndReturn(run func(db *gorm.DB, assetID uuid.UUID, assetVersionName string) error) *ExternalReferenceRepository_DeleteByAssetVersion_Call {
	_c.Call.Return(run)
	return _c
}

// FindByAssetID provides a mock function for the type ExternalReferenceRepository
func (_mock *ExternalReferenceRepository) FindByAssetID(db *gorm.DB, assetID uuid.UUID) ([]models.ExternalReference, error) {
	ret := _mock.Called(db, assetID)

	if len(ret) == 0 {
		panic("no return value specified for FindByAssetID")
	}

	var r0 []models.ExternalReference
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*gorm.DB, uuid.UUID) ([]models.ExternalReference, error)); ok {
		return returnFunc(db, assetID)
	}
	if returnFunc, ok := ret.Get(0).(func(*gorm.DB, uuid.UUID) []models.ExternalReference); ok {
		r0 = returnFunc(db, assetID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.ExternalReference)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*gorm.DB, uuid.UUID) error); ok {
		r1 = returnFunc(db, assetID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExternalReferenceRepository_FindByAssetID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByAssetID'
type ExternalReferenceRepository_FindByAssetID_Call struct {
	*mock.Call
}

// FindByAssetID is a helper method to define mock.On call
//   - db *gorm.DB
//   - assetID uuid.UUID
func (_e *ExternalReferenceRepository_Expecter) FindByAssetID(db interface{}, assetID interface{}) *ExternalReferenceRepository_FindByAssetID_Call {
	return &ExternalReferenceRepository_FindByAssetID_Call{Call: _e.mock.On("FindByAssetID", db, assetID)}
}

func (_c *ExternalReferenceRepository_FindByAssetID_Call) Run(run func(db *gorm.DB, assetID uuid.UUID)) *ExternalReferenceRepository_FindByAssetID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *gorm.DB
		if args[0] != nil {
			arg0 = args[0].(*gorm.DB)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *ExternalReferenceRepository_FindByAssetID_Call) Return(externalReferences []models.ExternalReference, err error) *ExternalReferenceRepository_FindByAssetID_Call {
	_c.Call.Return(externalReferences, err)
	return _c
}

func (_c *ExternalReferenceRepository_FindByAssetID_Call) RunAndReturn(run func(db *gorm.DB, assetID uuid.UUID) ([]models.ExternalReference, error)) *ExternalReferenceRepository_FindByAssetID_Call {
	_c.Call.Return(run)
	return _c
}

// FindByAssetVersion provides a mock function for the type ExternalReferenceRepository
func (_mock *ExternalReferenceRepository) FindByAssetVersion(db *gorm.DB, assetID uuid.UUID, assetVersionName string) ([]models.ExternalReference, error) {
	ret := _mock.Called(db, assetID, assetVersionName)

	if len(ret) == 0 {
		panic("no return value specified for FindByAssetVersion")
	}

	var r0 []models.ExternalReference
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*gorm.DB, uuid.UUID, string) ([]models.ExternalReference, error)); ok {
		return returnFunc(db, assetID, assetVersionName)
	}
	if returnFunc, ok := ret.Get(0).(func(*gorm.DB, uuid.UUID, string) []models.ExternalReference); ok {
		r0 = returnFunc(db, assetID, assetVersionName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.ExternalReference)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*gorm.DB, uuid.UUID, string) error); ok {
		r1 = returnFunc(db, assetID, assetVersionName)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// ExternalReferenceRepository_FindByAssetVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindByAssetVersion'
type ExternalReferenceRepository_FindByAssetVersion_Call struct {
	*mock.Call
}

// FindByAssetVersion is a helper method to define mock.On call
//   - db *gorm.DB
//   - assetID uuid.UUID
//   - assetVersionName string
func (_e *ExternalReferenceRepository_Expecter) FindByAssetVersion(db interface{}, assetID interface{}, assetVersionName interface{}) *ExternalReferenceRepository_FindByAssetVersion_Call {
	return &ExternalReferenceRepository_FindByAssetVersion_Call{Call: _e.mock.On("FindByAssetVersion", db, assetID, assetVersionName)}
}

func (_c *ExternalReferenceRepository_FindByAssetVersion_Call) Run(run func(db *gorm.DB, assetID uuid.UUID, assetVersionName string)) *ExternalReferenceRepository_FindByAssetVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *gorm.DB
		if args[0] != nil {
			arg0 = args[0].(*gorm.DB)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *ExternalReferenceRepository_FindByAssetVersion_Call) Return(externalReferences []models.ExternalReference, err error) *ExternalReferenceRepository_FindByAssetVersion_Call {
	_c.Call.Return(externalReferences, err)
	return _c
}

func (_c *ExternalReferenceRepository_FindByAssetVersion_Call) RunAndReturn(run func(db *gorm.DB, assetID uuid.UUID, assetVersionName string) ([]models.ExternalReference, error)) *ExternalReferenceRepository_FindByAssetVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetDB provides a mock function for the type ExternalReferenceRepository
func (_mock *ExternalReferenceRepository) GetDB(db *gorm.DB) *gorm.DB {
	ret := _mock.Called(db)

	if len(ret) == 0 {
		panic("no return value specified for GetDB")
	}

	var r0 *gorm.DB
	if returnFunc, ok := ret.Get(0).(func(*gorm.DB) *gorm.DB); ok {
		r0 = returnFunc(db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}
	return r0
}

// ExternalReferenceRepository_GetDB_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDB'
type ExternalReferenceRepository_GetDB_Call struct {
	*mock.Call
}

// GetDB is a helper method to define mock.On call
//   - db *gorm.DB
func (_e *ExternalReferenceRepository_Expecter) GetDB(db interface{}) *ExternalReferenceRepository_GetDB_Call {
	return &ExternalReferenceRepository_GetDB_Call{Call: _e.mock.On("GetDB", db)}
}

func (_c *ExternalReferenceRepository_GetDB_Call) Run(run func(db *gorm.DB)) *ExternalReferenceRepository_GetDB_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *gorm.DB
		if args[0] != nil {
			arg0 = args[0].(*gorm.DB)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *ExternalReferenceRepository_GetDB_Call) Return(dB *gorm.DB) *ExternalReferenceRepository_GetDB_Call {
	_c.Call.Return(dB)
	return _c
}

func (_c *ExternalReferenceRepository_GetDB_Call) RunAndReturn(run func(db *gorm.DB) *gorm.DB) *ExternalReferenceRepository_GetDB_Call {
	_c.Call.Return(run)
	return _c
}
