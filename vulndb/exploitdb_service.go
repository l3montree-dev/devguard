package vulndb

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"strings"
	"time"

	"encoding/csv"

	"github.com/l3montree-dev/devguard/database/models"
	"github.com/l3montree-dev/devguard/shared"
	"github.com/pkg/errors"
)

type exploitDBService struct {
	exploitRepository shared.ExploitRepository
	httpClient        *http.Client
}

func NewExploitDBService(exploitRepository shared.ExploitRepository) exploitDBService {
	return exploitDBService{
		exploitRepository: exploitRepository,
		httpClient:        &http.Client{},
	}
}

// Infromation provided under GNU General Public License v2.0 or later, by OffSec Services Limited
var exploitDBURL = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"

func (s *exploitDBService) fetchCSV(ctx context.Context) error {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, exploitDBURL, nil)

	if err != nil {
		return err
	}

	res, err := s.httpClient.Do(req)
	if err != nil {
		return err
	}

	defer res.Body.Close()
	csvReader := csv.NewReader(res.Body)
	records, err := csvReader.ReadAll()
	if err != nil {
		return errors.Wrap(err, "could not read csv")
	}
	exploits := make(map[string]models.Exploit, 0)
	for _, record := range records[1:] {
		id := fmt.Sprintf("exploitdb:%s", record[0])

		datePublished, err := time.Parse(time.DateOnly, record[3])
		if err != nil {
			slog.Warn("could not parse date published", "date", record[3], "exploitId", id)
			continue
		}
		var dateUpdated *time.Time = nil
		du, err := time.Parse(time.DateOnly, record[9])
		if err == nil {
			dateUpdated = &du
		}

		description := record[2]
		author := record[4]

		verified := record[10]
		codes := record[11]
		tags := record[12]
		sourceURL := record[16]

		// parse the codes
		if codes != "" {
			for _, code := range strings.Split(codes, ";") {
				if !strings.HasPrefix(code, "CVE-") {
					continue
				}
				exploitModel := models.Exploit{
					ID: id,

					Description: description,
					Published:   &datePublished,
					Updated:     dateUpdated,
					Author:      author,
					Verified:    verified == "1",
					SourceURL:   sourceURL,
					Tags:        tags,
					CVEID:       code,
				}

				if existingExploit, exist := exploits[id]; exist {
					// check the dateUpdated, maybe it is more recent
					if dateUpdated != nil && existingExploit.Updated != nil && dateUpdated.After(*existingExploit.Updated) {
						exploits[id] = exploitModel
					}
				} else {
					exploits[id] = exploitModel
				}
			}
		}
	}
	// get all values of the map
	exploitModels := make([]models.Exploit, len(exploits))
	i := 0
	for _, exploitModel := range exploits {
		exploitModels[i] = exploitModel
		i++
	}

	return s.exploitRepository.SaveBatch(nil, exploitModels)
}

func (s exploitDBService) Mirror() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	return s.fetchCSV(ctx)
}
