package vulndb

import (
	"archive/zip"
	"bytes"
	"context"
	"encoding/json"
	"io"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/l3montree-dev/devguard/database/models"
	"github.com/l3montree-dev/devguard/shared"
	"github.com/pkg/errors"
)

type githubExploitDBService struct {
	exploitRepository shared.ExploitRepository
	httpClient        *http.Client
}

func NewGithubExploitDBService(exploitRepository shared.ExploitRepository) githubExploitDBService {
	return githubExploitDBService{
		exploitRepository: exploitRepository,
		httpClient:        &http.Client{},
	}
}

var githubExploitDBURL = "https://github.com/nomi-sec/PoC-in-GitHub/archive/refs/heads/master.zip"

func (s *githubExploitDBService) fetchGithubExploits(ctx context.Context) error {
	// download exploits from the github repository
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, githubExploitDBURL, nil)
	if err != nil {
		return errors.Wrap(err, "could not create request")
	}

	res, err := s.httpClient.Do(req)
	if err != nil {
		return errors.Wrap(err, "could not download github exploits")
	}

	b, err := io.ReadAll(res.Body)
	if err != nil {
		return errors.Wrap(err, "could not read response body")
	}

	defer res.Body.Close()

	// Unzip the file
	zipListing, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))
	if err != nil {
		return errors.Wrap(err, "could not unzip github exploits")
	}

	// Read the json files and save them to the database

	//make exploits map
	exploits := make(map[string]models.Exploit, 0)

	// iterate over the files in the zip
	for _, f := range zipListing.File {
		// check if the file is a json file
		if strings.HasSuffix(f.Name, ".json") {

			// extract the CVE name from the file name
			splitPath := strings.Split(f.Name, "/")
			cveNameWithExtension := splitPath[len(splitPath)-1]
			cveName := strings.TrimSuffix(cveNameWithExtension, ".json")
			if !strings.HasPrefix(cveName, "CVE") {
				continue
			}

			//tmp to save alle exploits from one json file
			var tmp []GithubExploitDTO

			// read the json file and convert it to byte array
			jsonFile, err := f.Open()
			if err != nil {
				return errors.Wrap(err, "could not open json file")
			}
			defer jsonFile.Close()
			byteValue, err := io.ReadAll(jsonFile)
			if err != nil {
				return errors.Wrap(err, "could not read json file")
			}

			// parse the json file
			err = json.Unmarshal(byteValue, &tmp)
			if err != nil {
				return errors.Wrap(err, "could not parse json file")
			}

			for _, exploit := range tmp {

				id := "github:" + strconv.Itoa(exploit.ID)

				exploitModel := models.Exploit{
					ID:          id,
					Published:   exploit.Published,
					Updated:     exploit.Updated,
					Author:      exploit.Owner.Login,
					SourceURL:   exploit.HTMLURL,
					Description: exploit.Description,
					CVEID:       cveName,
					Forks:       exploit.Forks,
					Watchers:    exploit.Watchers,
					Subscribers: exploit.Subscribers,
					Stars:       exploit.Stars,
				}

				//save the exploit in the map
				if existingExploit, exist := exploits[id]; exist {
					// check the dateUpdated, maybe it is more recent
					if exploit.Updated != nil && existingExploit.Updated != nil && exploit.Updated.After(*existingExploit.Updated) {
						exploits[id] = exploitModel
					}
				} else {
					exploits[id] = exploitModel
				}
			}

		}

	}

	// get all values of the map
	exploitModels := make([]models.Exploit, len(exploits))
	i := 0
	for _, exploitModel := range exploits {
		exploitModels[i] = exploitModel
		i++
	}

	// save the exploits to the database
	return s.exploitRepository.SaveBatch(nil, exploitModels)
}

func (s githubExploitDBService) Mirror() error {
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	return s.fetchGithubExploits(ctx)
}
