rules:
  - id: authentication-bypass-without-scope-check
    patterns:
      - pattern: |
          if $PUBLIC_CHECK {
            core.SetIsPublicRequest($CTX)
          } else {
            ...
            return echo.NewHTTPError(403, "forbidden")
          }
      - pattern-not-inside: |
          if $PUBLIC_CHECK && $ACT == core.ActionRead {
            core.SetIsPublicRequest($CTX)
          } else {
            ...
          }
    message: |
      Public access bypass without checking the action scope.
      Only READ actions should bypass authentication on public resources.
      Add: if $PUBLIC && act == core.ActionRead { ... }
    languages: [go]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-284: Improper Access Control"

  - id: middleware-not-enforcing-rbac
    patterns:
      - pattern: |
          $ROUTER.$METHOD("...", $HANDLER)
      - pattern-not-inside: |
          $ROUTER.$METHOD("...", $HANDLER, $MIDDLEWARE)
      - pattern-not-inside: |
          $GROUP := $ROUTER.Group("...", $MIDDLEWARE, ...)
          ...
          $GROUP.$METHOD("...", $HANDLER)
      - metavariable-regex:
          metavariable: $METHOD
          regex: (POST|PUT|PATCH|DELETE|GET)
    message: |
      Potentially sensitive endpoint registered without RBAC middleware.
      Ensure routes have proper access control middleware.
      Apply middleware: router.Method("/path", handler, rbacMiddleware(...))
    languages: [go]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-306: Missing Authentication for Critical Function"

  - id: hardcoded-rbac-scope
    patterns:
      - pattern-either:
          - pattern: rbac.IsAllowed($USER, "organization", $ACT)
          - pattern: rbac.IsAllowed($USER, "project", $ACT)
          - pattern: rbac.IsAllowed($USER, "asset", $ACT)
          - pattern: rbac.GrantRoleIn$SCOPE($USER, "admin", ...)
          - pattern: rbac.GrantRoleIn$SCOPE($USER, "member", ...)
      - pattern-not: rbac.IsAllowed($USER, core.$OBJ, $ACT)
      - pattern-not: rbac.GrantRoleIn$SCOPE($USER, core.$ROLE, ...)
    message: |
      Hardcoded RBAC object/role strings instead of using core constants.
      Use core.ObjectOrganization, core.ObjectProject, core.ObjectAsset, core.RoleAdmin, core.RoleMember.
      This prevents typos and ensures consistency.
    languages: [go]
    severity: WARNING
    metadata:
      category: maintainability

  - id: sensitive-data-in-logs
    patterns:
      - pattern-either:
          - pattern: slog.$LEVEL("...", ..., "$KEY", $SECRET, ...)
          - pattern: slog.$LEVEL("...", "$KEY", $SECRET)
          - pattern: log.$METHOD("...", ..., $SECRET, ...)
      - pattern-not-inside: |
          slog.$LEVEL(..., utils.HashString(...), ...)
      - metavariable-regex:
          metavariable: $KEY
          regex: (.*[Ss]ecret.*|.*[Tt]oken.*|.*[Pp]assword.*)
    message: |
      Potentially logging sensitive data (secret, token, password).
      Secrets should never be logged. Mask or remove from log statements.
    languages: [go]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-532: Insertion of Sensitive Information into Log File"
  - id: direct-sql-without-transaction
    patterns:
      - pattern-either:
          - pattern: |
              db.Exec($QUERY, ...)
          - pattern: |
              db.Query($QUERY, ...)
      - pattern-not-inside: |
          tx, $ERR := $DB.Begin()
          ...
      - pattern-inside: |
          func $MIGRATION_FUNC(...) error {
            ...
          }
      - metavariable-regex:
          metavariable: $MIGRATION_FUNC
          regex: (.*Up|.*Down|.*Migration)
    message: |
      Database operation in migration without transaction context.
      Migrations should use transactions to ensure atomicity. Wrap operations in tx.Begin() / tx.Commit().
    languages: [go]
    severity: WARNING
    metadata:
      category: best-practice

  - id: missing-rollback-on-migration-error
    patterns:
      - pattern: |
          tx, $ERR := $DB.Begin()
          ...
          if $ERR := ...; $ERR != nil {
            return $ERR
          }
      - pattern-not-inside: |
          tx, $ERR := $DB.Begin()
          ...
          if $ERR := ...; $ERR != nil {
            tx.Rollback()
            ...
          }
      - pattern-inside: |
          func $MIGRATION_FUNC(...) error {
            ...
          }
    message: |
      Migration error handling doesn't rollback transaction.
      Always call tx.Rollback() before returning error to prevent partial migration state.
    languages: [go]
    severity: ERROR
    metadata:
      category: correctness
  - id: missing-self-demotion-check-in-changerole
    patterns:
      - pattern: |
          func $FUNC($CTX core.Context) error {
            ...
            userID := $CTX.Param("userID")
            ...
            rbac.RevokeRoleIn$SCOPE($USER, $ROLE, ...)
            ...
          }
      - pattern-not-inside: |
          func $FUNC($CTX core.Context) error {
            ...
            if userID == core.GetSession($CTX).GetUserID() {
              ...
            }
            ...
          }
      - pattern-not-inside: |
          func $FUNC($CTX core.Context) error {
            ...
            currentUserID := core.GetSession($CTX).GetUserID()
            ...
            if userID == currentUserID {
              ...
            }
            ...
          }
      - metavariable-regex:
          metavariable: $FUNC
          regex: (ChangeRole|UpdateRole|ModifyRole)
    message: |
      ChangeRole function is missing self-demotion check.
      Users should not be able to change their own role to prevent accidental lockout.
      Add: if userID == core.GetSession(c).GetUserID() { return echo.NewHTTPError(400, "cannot change your own role") }
    languages: [go]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-285: Improper Authorization"
      confidence: HIGH

  - id: public-request-database-write
    patterns:
      - pattern-either:
          - pattern: |
              go func() {
                ...
                $REPO.Save($TX, $OBJ)
                ...
              }()
          - pattern: |
              go func() {
                ...
                $REPO.Update($TX, $OBJ)
                ...
              }()
      - pattern-inside: |
          func $FUNC(...) ... {
            ...
            if $PUBLIC_CHECK {
              core.SetIsPublicRequest($CTX)
              ...
            }
            ...
          }
      - pattern-not-inside: |
          if !core.IsPublicRequest($CTX) {
            ...
          }
    message: |
      Database write operation in goroutine may execute for public requests.
      This can be abused for write amplification attacks.
      Wrap the goroutine with: if !core.IsPublicRequest(ctx) { ... }
    languages: [go]
    severity: WARNING
    metadata:
      category: security
      cwe: "CWE-400: Uncontrolled Resource Consumption"

  - id: secrets-in-dto-struct
    patterns:
      - pattern-either:
          - pattern: |
              type $DTO struct {
                ...
                $SECRET *uuid.UUID `json:"$FIELD_NAME"`
                ...
              }
          - pattern: |
              type $DTO struct {
                ...
                $SECRET uuid.UUID `json:"$FIELD_NAME"`
                ...
              }
      - metavariable-regex:
          metavariable: $FIELD_NAME
          regex: (.*[Ss]ecret.*|.*[Tt]oken.*|.*[Kk]ey.*|.*[Pp]assword.*)
      - metavariable-regex:
          metavariable: $DTO
          regex: .*DTO$
    message: |
      DTO struct contains a secret field that may be exposed in API responses.
      Create separate DTOs: one for public/normal responses (without secrets) and one for authenticated/privileged responses (with secrets).
      Use ToDTO() for normal responses and ToDTOWithSecrets() for privileged endpoints.
    languages: [go]
    severity: WARNING
    metadata:
      category: security
      cwe: "CWE-200: Exposure of Sensitive Information"
      confidence: MEDIUM

  - id: missing-last-admin-check
    patterns:
      - pattern-either:
          - pattern: |
              func $FUNC($CTX core.Context) error {
                ...
                rbac.RevokeRoleIn$SCOPE($USER, core.RoleAdmin, ...)
                ...
              }
          - pattern: |
              func $FUNC($CTX core.Context) error {
                ...
                rbac.RevokeRoleIn$SCOPE($USER, "admin", ...)
                ...
              }
      - pattern-not-inside: |
          func $FUNC($CTX core.Context) error {
            ...
            adminCount := ...
            ...
            if adminCount <= 1 {
              ...
            }
            ...
          }
      - metavariable-regex:
          metavariable: $FUNC
          regex: (ChangeRole|RemoveMember|UpdateRole|DeleteMember)
    message: |
      Revoking admin role without checking if this is the last admin.
      This can orphan the resource with no admins able to manage it.
      Count admins before revoking and prevent removal if count <= 1.
    languages: [go]
    severity: WARNING
    metadata:
      category: security
      cwe: "CWE-285: Improper Authorization"

  - id: error-check-suppressed-without-logging
    patterns:
      - pattern-either:
          - pattern: |
              $FUNC(...) // nolint:errcheck
          - pattern: |
              _ = $FUNC(...)
      - pattern-not-inside: |
          if $ERR := $FUNC(...); $ERR != nil {
            ...
          }
      - pattern-not-inside: |
          return $FUNC(...).Error
      - patter-not-inside: |
          return $FUNC(...)
      - metavariable-regex:
          metavariable: $FUNC
          regex: (.*Revoke.*|.*Grant.*|.*Save.*|.*Update.*|.*Delete.*)
    message: |
      Error from critical operation is ignored without logging.
      Consider logging the error even if you can't handle it: slog.Warn("operation failed", "err", err)
    languages: [go]
    severity: INFO
    metadata:
      category: best-practice

  - id: invite-members-without-org-check
    patterns:
      - pattern: |
          func $FUNC($CTX core.Context) error {
            ...
            members, $ERR := rbac.GetAllMembersOf$SCOPE(...)
            ...
            for _, newMemberID := range $REQ.Ids {
              if !utils.Contains(members, newMemberID) {
                return echo.NewHTTPError($CODE, "user is not a member of the $ENTITY")
              }
              ...
            }
            ...
          }
      - metavariable-regex:
          metavariable: $FUNC
          regex: (InviteMembers|AddMembers)
      - metavariable-regex:
          metavariable: $SCOPE
          regex: (Project|Asset)
      - metavariable-regex:
          metavariable: $ENTITY
          regex: (organization|Organization)
    message: |
      Business logic mismatch: Code checks if user is member of $SCOPE but error message says $ENTITY.
      Clarify requirement: Should users be members of the organization or the $SCOPE before being invited?
    languages: [go]
    severity: WARNING
    metadata:
      category: maintainability
