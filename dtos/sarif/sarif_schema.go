// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package sarif

import (
	"encoding/json"
	"fmt"
	"reflect"
	"regexp"
	"strings"
	"time"

	"github.com/go-viper/mapstructure/v2"
)

// A physical or virtual address, or a range of addresses, in an 'addressable
// region' (memory or a binary file).
type Address struct {
	// The address expressed as a byte offset from the start of the addressable
	// region.
	AbsoluteAddress int `json:"absoluteAddress,omitempty" yaml:"absoluteAddress,omitempty" mapstructure:"absoluteAddress,omitempty"`

	// A human-readable fully qualified name that is associated with the address.
	FullyQualifiedName *string `json:"fullyQualifiedName,omitempty" yaml:"fullyQualifiedName,omitempty" mapstructure:"fullyQualifiedName,omitempty"`

	// The index within run.addresses of the cached object for this address.
	Index int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// An open-ended string that identifies the address kind. 'data', 'function',
	// 'header','instruction', 'module', 'page', 'section', 'segment', 'stack',
	// 'stackFrame', 'table' are well-known values.
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// The number of bytes in this range of addresses.
	Length *int `json:"length,omitempty" yaml:"length,omitempty" mapstructure:"length,omitempty"`

	// A name that is associated with the address, e.g., '.text'.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// The byte offset of this address from the absolute or relative address of the
	// parent object.
	OffsetFromParent *int `json:"offsetFromParent,omitempty" yaml:"offsetFromParent,omitempty" mapstructure:"offsetFromParent,omitempty"`

	// The index within run.addresses of the parent object.
	ParentIndex int `json:"parentIndex,omitempty" yaml:"parentIndex,omitempty" mapstructure:"parentIndex,omitempty"`

	// Key/value pairs that provide additional information about the address.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The address expressed as a byte offset from the absolute address of the
	// top-most parent object.
	RelativeAddress *int `json:"relativeAddress,omitempty" yaml:"relativeAddress,omitempty" mapstructure:"relativeAddress,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Address) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain Address
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["absoluteAddress"]; !ok || v == nil {
		plain.AbsoluteAddress = -1.0
	}
	if -1 > plain.AbsoluteAddress {
		return fmt.Errorf("field %s: must be >= %v", "absoluteAddress", -1)
	}
	if v, ok := raw["index"]; !ok || v == nil {
		plain.Index = -1.0
	}
	if -1 > plain.Index {
		return fmt.Errorf("field %s: must be >= %v", "index", -1)
	}
	if v, ok := raw["parentIndex"]; !ok || v == nil {
		plain.ParentIndex = -1.0
	}
	if -1 > plain.ParentIndex {
		return fmt.Errorf("field %s: must be >= %v", "parentIndex", -1)
	}
	*j = Address(plain)
	return nil
}

// A single artifact. In some cases, this artifact might be nested within another
// artifact.
type Artifact struct {
	// The contents of the artifact.
	Contents *ArtifactContent `json:"contents,omitempty" yaml:"contents,omitempty" mapstructure:"contents,omitempty"`

	// A short description of the artifact.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Specifies the encoding for an artifact object that refers to a text file.
	Encoding *string `json:"encoding,omitempty" yaml:"encoding,omitempty" mapstructure:"encoding,omitempty"`

	// A dictionary, each of whose keys is the name of a hash function and each of
	// whose values is the hashed value of the artifact produced by the specified hash
	// function.
	Hashes map[string]string `json:"hashes,omitempty" yaml:"hashes,omitempty" mapstructure:"hashes,omitempty"`

	// The Coordinated Universal Time (UTC) date and time at which the artifact was
	// most recently modified. See "Date/time properties" in the SARIF spec for the
	// required format.
	LastModifiedTimeUtc *time.Time `json:"lastModifiedTimeUtc,omitempty" yaml:"lastModifiedTimeUtc,omitempty" mapstructure:"lastModifiedTimeUtc,omitempty"`

	// The length of the artifact in bytes.
	Length int `json:"length,omitempty" yaml:"length,omitempty" mapstructure:"length,omitempty"`

	// The location of the artifact.
	Location *ArtifactLocation `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// The MIME type (RFC 2045) of the artifact.
	MimeType *string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// The offset in bytes of the artifact within its containing artifact.
	Offset *int `json:"offset,omitempty" yaml:"offset,omitempty" mapstructure:"offset,omitempty"`

	// IDentifies the index of the immediate parent of the artifact, if this artifact
	// is nested.
	ParentIndex int `json:"parentIndex,omitempty" yaml:"parentIndex,omitempty" mapstructure:"parentIndex,omitempty"`

	// Key/value pairs that provide additional information about the artifact.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The role or roles played by the artifact in the analysis.
	Roles []ArtifactRolesElem `json:"roles,omitempty" yaml:"roles,omitempty" mapstructure:"roles,omitempty"`

	// Specifies the source language for any artifact object that refers to a text
	// file that contains source code.
	SourceLanguage *string `json:"sourceLanguage,omitempty" yaml:"sourceLanguage,omitempty" mapstructure:"sourceLanguage,omitempty"`
}

// A change to a single artifact.
type ArtifactChange struct {
	// The location of the artifact to change.
	ArtifactLocation ArtifactLocation `json:"artifactLocation" yaml:"artifactLocation" mapstructure:"artifactLocation"`

	// Key/value pairs that provide additional information about the change.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An array of replacement objects, each of which represents the replacement of a
	// single region in a single artifact specified by 'artifactLocation'.
	Replacements []Replacement `json:"replacements" yaml:"replacements" mapstructure:"replacements"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArtifactChange) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["artifactLocation"]; raw != nil && !ok {
		return fmt.Errorf("field artifactLocation in ArtifactChange: required")
	}
	if _, ok := raw["replacements"]; raw != nil && !ok {
		return fmt.Errorf("field replacements in ArtifactChange: required")
	}
	type Plain ArtifactChange
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Replacements != nil && len(plain.Replacements) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "replacements", 1)
	}
	*j = ArtifactChange(plain)
	return nil
}

// Represents the contents of an artifact.
type ArtifactContent struct {
	// MIME Base64-encoded content from a binary artifact, or from a text artifact in
	// its original encoding.
	Binary *string `json:"binary,omitempty" yaml:"binary,omitempty" mapstructure:"binary,omitempty"`

	// Key/value pairs that provide additional information about the artifact content.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An alternate rendered representation of the artifact (e.g., a decompiled
	// representation of a binary region).
	Rendered *MultiformatMessageString `json:"rendered,omitempty" yaml:"rendered,omitempty" mapstructure:"rendered,omitempty"`

	// UTF-8-encoded content from a text artifact.
	Text *string `json:"text,omitempty" yaml:"text,omitempty" mapstructure:"text,omitempty"`
}

// Specifies the location of an artifact.
type ArtifactLocation struct {
	// A short description of the artifact location.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The index within the run artifacts array of the artifact object associated with
	// the artifact location.
	Index int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// Key/value pairs that provide additional information about the artifact
	// location.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A string containing a valid relative or absolute URI.
	URI *string `json:"uri,omitempty" yaml:"uri,omitempty" mapstructure:"uri,omitempty"`

	// A string which indirectly specifies the absolute URI with respect to which a
	// relative URI in the "uri" property is interpreted.
	URIBaseID *string `json:"uriBaseID,omitempty" yaml:"uriBaseID,omitempty" mapstructure:"uriBaseID,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArtifactLocation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain ArtifactLocation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		plain.Index = -1.0
	}
	if -1 > plain.Index {
		return fmt.Errorf("field %s: must be >= %v", "index", -1)
	}
	*j = ArtifactLocation(plain)
	return nil
}

type ArtifactRolesElem string

const ArtifactRolesElemAdded ArtifactRolesElem = "added"
const ArtifactRolesElemAnalysisTarget ArtifactRolesElem = "analysisTarget"
const ArtifactRolesElemAttachment ArtifactRolesElem = "attachment"
const ArtifactRolesElemDebugOutputFile ArtifactRolesElem = "debugOutputFile"
const ArtifactRolesElemDeleted ArtifactRolesElem = "deleted"
const ArtifactRolesElemDirectory ArtifactRolesElem = "directory"
const ArtifactRolesElemDriver ArtifactRolesElem = "driver"
const ArtifactRolesElemExtension ArtifactRolesElem = "extension"
const ArtifactRolesElemMemoryContents ArtifactRolesElem = "memoryContents"
const ArtifactRolesElemModified ArtifactRolesElem = "modified"
const ArtifactRolesElemPolicy ArtifactRolesElem = "policy"
const ArtifactRolesElemReferencedOnCommandLine ArtifactRolesElem = "referencedOnCommandLine"
const ArtifactRolesElemRenamed ArtifactRolesElem = "renamed"
const ArtifactRolesElemResponseFile ArtifactRolesElem = "responseFile"
const ArtifactRolesElemResultFile ArtifactRolesElem = "resultFile"
const ArtifactRolesElemStandardStream ArtifactRolesElem = "standardStream"
const ArtifactRolesElemTaxonomy ArtifactRolesElem = "taxonomy"
const ArtifactRolesElemToolSpecifiedConfiguration ArtifactRolesElem = "toolSpecifiedConfiguration"
const ArtifactRolesElemTracedFile ArtifactRolesElem = "tracedFile"
const ArtifactRolesElemTranslation ArtifactRolesElem = "translation"
const ArtifactRolesElemUncontrolled ArtifactRolesElem = "uncontrolled"
const ArtifactRolesElemUnmodified ArtifactRolesElem = "unmodified"
const ArtifactRolesElemUserSpecifiedConfiguration ArtifactRolesElem = "userSpecifiedConfiguration"

var enumValues_ArtifactRolesElem = []interface{}{
	"analysisTarget",
	"attachment",
	"responseFile",
	"resultFile",
	"standardStream",
	"tracedFile",
	"unmodified",
	"modified",
	"added",
	"deleted",
	"renamed",
	"uncontrolled",
	"driver",
	"extension",
	"translation",
	"taxonomy",
	"policy",
	"referencedOnCommandLine",
	"memoryContents",
	"directory",
	"userSpecifiedConfiguration",
	"toolSpecifiedConfiguration",
	"debugOutputFile",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArtifactRolesElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ArtifactRolesElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ArtifactRolesElem, v)
	}
	*j = ArtifactRolesElem(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Artifact) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain Artifact
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["length"]; !ok || v == nil {
		plain.Length = -1.0
	}
	if -1 > plain.Length {
		return fmt.Errorf("field %s: must be >= %v", "length", -1)
	}
	if plain.MimeType != nil {
		if matched, _ := regexp.MatchString(`[^/]+/.+`, string(*plain.MimeType)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "MimeType", `[^/]+/.+`)
		}
	}
	if plain.Offset != nil && 0 > *plain.Offset {
		return fmt.Errorf("field %s: must be >= %v", "offset", 0)
	}
	if v, ok := raw["parentIndex"]; !ok || v == nil {
		plain.ParentIndex = -1.0
	}
	if -1 > plain.ParentIndex {
		return fmt.Errorf("field %s: must be >= %v", "parentIndex", -1)
	}
	if v, ok := raw["roles"]; !ok || v == nil {
		plain.Roles = []ArtifactRolesElem{}
	}
	*j = Artifact(plain)
	return nil
}

// An artifact relevant to a result.
type Attachment struct {
	// The location of the attachment.
	ArtifactLocation ArtifactLocation `json:"artifactLocation" yaml:"artifactLocation" mapstructure:"artifactLocation"`

	// A message describing the role played by the attachment.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Key/value pairs that provide additional information about the attachment.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An array of rectangles specifying areas of interest within the image.
	Rectangles []Rectangle `json:"rectangles,omitempty" yaml:"rectangles,omitempty" mapstructure:"rectangles,omitempty"`

	// An array of regions of interest within the attachment.
	Regions []Region `json:"regions,omitempty" yaml:"regions,omitempty" mapstructure:"regions,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Attachment) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["artifactLocation"]; raw != nil && !ok {
		return fmt.Errorf("field artifactLocation in Attachment: required")
	}
	type Plain Attachment
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["rectangles"]; !ok || v == nil {
		plain.Rectangles = []Rectangle{}
	}
	if v, ok := raw["regions"]; !ok || v == nil {
		plain.Regions = []Region{}
	}
	*j = Attachment(plain)
	return nil
}

// A set of threadFlows which together describe a pattern of code execution
// relevant to detecting a result.
type CodeFlow struct {
	// A message relevant to the code flow.
	Message Message `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Key/value pairs that provide additional information about the code flow.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An array of one or more unique threadFlow objects, each of which describes the
	// progress of a program through a thread of execution.
	ThreadFlows []ThreadFlow `json:"threadFlows" yaml:"threadFlows" mapstructure:"threadFlows"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CodeFlow) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["threadFlows"]; raw != nil && !ok {
		return fmt.Errorf("field threadFlows in CodeFlow: required")
	}
	type Plain CodeFlow
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ThreadFlows != nil && len(plain.ThreadFlows) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "threadFlows", 1)
	}
	*j = CodeFlow(plain)
	return nil
}

// Information about how a specific rule or notification was reconfigured at
// runtime.
type ConfigurationOverride struct {
	// Specifies how the rule or notification was configured during the scan.
	Configuration ReportingConfiguration `json:"configuration" yaml:"configuration" mapstructure:"configuration"`

	// A reference used to locate the descriptor whose configuration was overridden.
	Descriptor ReportingDescriptorReference `json:"descriptor" yaml:"descriptor" mapstructure:"descriptor"`

	// Key/value pairs that provide additional information about the configuration
	// override.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigurationOverride) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["configuration"]; raw != nil && !ok {
		return fmt.Errorf("field configuration in ConfigurationOverride: required")
	}
	if _, ok := raw["descriptor"]; raw != nil && !ok {
		return fmt.Errorf("field descriptor in ConfigurationOverride: required")
	}
	type Plain ConfigurationOverride
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = ConfigurationOverride(plain)
	return nil
}

// Describes how a converter transformed the output of a static analysis tool from
// the analysis tool's native output format into the SARIF format.
type Conversion struct {
	// The locations of the analysis tool's per-run log files.
	AnalysisToolLogFiles []ArtifactLocation `json:"analysisToolLogFiles,omitempty" yaml:"analysisToolLogFiles,omitempty" mapstructure:"analysisToolLogFiles,omitempty"`

	// An invocation object that describes the invocation of the converter.
	Invocation *Invocation `json:"invocation,omitempty" yaml:"invocation,omitempty" mapstructure:"invocation,omitempty"`

	// Key/value pairs that provide additional information about the conversion.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A tool object that describes the converter.
	Tool Tool `json:"tool" yaml:"tool" mapstructure:"tool"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Conversion) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["tool"]; raw != nil && !ok {
		return fmt.Errorf("field tool in Conversion: required")
	}
	type Plain Conversion
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["analysisToolLogFiles"]; !ok || v == nil {
		plain.AnalysisToolLogFiles = []ArtifactLocation{}
	}
	*j = Conversion(plain)
	return nil
}

// Represents a directed edge in a graph.
type Edge struct {
	// A string that uniquely identifies the edge within its graph.
	ID string `json:"id" yaml:"id" mapstructure:"id"`

	// A short description of the edge.
	Label Message `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// Key/value pairs that provide additional information about the edge.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// IDentifies the source node (the node at which the edge starts).
	SourceNodeID string `json:"sourceNodeID" yaml:"sourceNodeID" mapstructure:"sourceNodeID"`

	// IDentifies the target node (the node at which the edge ends).
	TargetNodeID string `json:"targetNodeID" yaml:"targetNodeID" mapstructure:"targetNodeID"`
}

// Represents the traversal of a single edge during a graph traversal.
type EdgeTraversal struct {
	// IDentifies the edge being traversed.
	EdgeID string `json:"edgeID" yaml:"edgeID" mapstructure:"edgeID"`

	// The values of relevant expressions after the edge has been traversed.
	FinalState map[string]MultiformatMessageString `json:"finalState,omitempty" yaml:"finalState,omitempty" mapstructure:"finalState,omitempty"`

	// A message to display to the user as the edge is traversed.
	Message Message `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Key/value pairs that provide additional information about the edge traversal.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The number of edge traversals necessary to return from a nested graph.
	StepOverEdgeCount *int `json:"stepOverEdgeCount,omitempty" yaml:"stepOverEdgeCount,omitempty" mapstructure:"stepOverEdgeCount,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EdgeTraversal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["edgeID"]; raw != nil && !ok {
		return fmt.Errorf("field edgeID in EdgeTraversal: required")
	}
	type Plain EdgeTraversal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.StepOverEdgeCount != nil && 0 > *plain.StepOverEdgeCount {
		return fmt.Errorf("field %s: must be >= %v", "stepOverEdgeCount", 0)
	}
	*j = EdgeTraversal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Edge) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Edge: required")
	}
	if _, ok := raw["sourceNodeID"]; raw != nil && !ok {
		return fmt.Errorf("field sourceNodeID in Edge: required")
	}
	if _, ok := raw["targetNodeID"]; raw != nil && !ok {
		return fmt.Errorf("field targetNodeID in Edge: required")
	}
	type Plain Edge
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Edge(plain)
	return nil
}

// Describes a runtime exception encountered during the execution of an analysis
// tool.
type Exception struct {
	// An array of exception objects each of which is considered a cause of this
	// exception.
	InnerExceptions []Exception `json:"innerExceptions,omitempty" yaml:"innerExceptions,omitempty" mapstructure:"innerExceptions,omitempty"`

	// A string that identifies the kind of exception, for example, the fully
	// qualified type name of an object that was thrown, or the symbolic name of a
	// signal.
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// A message that describes the exception.
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Key/value pairs that provide additional information about the exception.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The sequence of function calls leading to the exception.
	Stack *Stack `json:"stack,omitempty" yaml:"stack,omitempty" mapstructure:"stack,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Exception) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain Exception
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["innerExceptions"]; !ok || v == nil {
		plain.InnerExceptions = []Exception{}
	}
	*j = Exception(plain)
	return nil
}

// The top-level element of an external property file.
type ExternalProperties struct {
	// Addresses that will be merged with a separate run.
	Addresses []Address `json:"addresses,omitempty" yaml:"addresses,omitempty" mapstructure:"addresses,omitempty"`

	// An array of artifact objects that will be merged with a separate run.
	Artifacts []Artifact `json:"artifacts,omitempty" yaml:"artifacts,omitempty" mapstructure:"artifacts,omitempty"`

	// A conversion object that will be merged with a separate run.
	Conversion *Conversion `json:"conversion,omitempty" yaml:"conversion,omitempty" mapstructure:"conversion,omitempty"`

	// The analysis tool object that will be merged with a separate run.
	Driver *ToolComponent `json:"driver,omitempty" yaml:"driver,omitempty" mapstructure:"driver,omitempty"`

	// Tool extensions that will be merged with a separate run.
	Extensions []ToolComponent `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// Key/value pairs that provide additional information that will be merged with a
	// separate run.
	ExternalizedProperties *PropertyBag `json:"externalizedProperties,omitempty" yaml:"externalizedProperties,omitempty" mapstructure:"externalizedProperties,omitempty"`

	// An array of graph objects that will be merged with a separate run.
	Graphs []Graph `json:"graphs,omitempty" yaml:"graphs,omitempty" mapstructure:"graphs,omitempty"`

	// A stable, unique identifier for this external properties object, in the form of
	// a GUID.
	Guid *string `json:"guid,omitempty" yaml:"guid,omitempty" mapstructure:"guid,omitempty"`

	// Describes the invocation of the analysis tool that will be merged with a
	// separate run.
	Invocations []Invocation `json:"invocations,omitempty" yaml:"invocations,omitempty" mapstructure:"invocations,omitempty"`

	// An array of logical locations such as namespaces, types or functions that will
	// be merged with a separate run.
	LogicalLocations []LogicalLocation `json:"logicalLocations,omitempty" yaml:"logicalLocations,omitempty" mapstructure:"logicalLocations,omitempty"`

	// Tool policies that will be merged with a separate run.
	Policies []ToolComponent `json:"policies,omitempty" yaml:"policies,omitempty" mapstructure:"policies,omitempty"`

	// Key/value pairs that provide additional information about the external
	// properties.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An array of result objects that will be merged with a separate run.
	Results []Result `json:"results,omitempty" yaml:"results,omitempty" mapstructure:"results,omitempty"`

	// A stable, unique identifier for the run associated with this external
	// properties object, in the form of a GUID.
	RunGuid *string `json:"runGuid,omitempty" yaml:"runGuid,omitempty" mapstructure:"runGuid,omitempty"`

	// The URI of the JSON schema corresponding to the version of the external
	// property file format.
	Schema *string `json:"schema,omitempty" yaml:"schema,omitempty" mapstructure:"schema,omitempty"`

	// Tool taxonomies that will be merged with a separate run.
	Taxonomies []ToolComponent `json:"taxonomies,omitempty" yaml:"taxonomies,omitempty" mapstructure:"taxonomies,omitempty"`

	// An array of threadFlowLocation objects that will be merged with a separate run.
	ThreadFlowLocations []ThreadFlowLocation `json:"threadFlowLocations,omitempty" yaml:"threadFlowLocations,omitempty" mapstructure:"threadFlowLocations,omitempty"`

	// Tool translations that will be merged with a separate run.
	Translations []ToolComponent `json:"translations,omitempty" yaml:"translations,omitempty" mapstructure:"translations,omitempty"`

	// The SARIF format version of this external properties object.
	Version *ExternalPropertiesVersion `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`

	// Requests that will be merged with a separate run.
	WebRequests []WebRequest `json:"webRequests,omitempty" yaml:"webRequests,omitempty" mapstructure:"webRequests,omitempty"`

	// Responses that will be merged with a separate run.
	WebResponses []WebResponse `json:"webResponses,omitempty" yaml:"webResponses,omitempty" mapstructure:"webResponses,omitempty"`
}

type ExternalPropertiesVersion string

const ExternalPropertiesVersionA210 ExternalPropertiesVersion = "2.1.0"

var enumValues_ExternalPropertiesVersion = []interface{}{
	"2.1.0",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalPropertiesVersion) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExternalPropertiesVersion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExternalPropertiesVersion, v)
	}
	*j = ExternalPropertiesVersion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalProperties) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain ExternalProperties
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["addresses"]; !ok || v == nil {
		plain.Addresses = []Address{}
	}
	if v, ok := raw["extensions"]; !ok || v == nil {
		plain.Extensions = []ToolComponent{}
	}
	if v, ok := raw["graphs"]; !ok || v == nil {
		plain.Graphs = []Graph{}
	}
	if plain.Guid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.Guid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Guid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["invocations"]; !ok || v == nil {
		plain.Invocations = []Invocation{}
	}
	if v, ok := raw["logicalLocations"]; !ok || v == nil {
		plain.LogicalLocations = []LogicalLocation{}
	}
	if v, ok := raw["policies"]; !ok || v == nil {
		plain.Policies = []ToolComponent{}
	}
	if v, ok := raw["results"]; !ok || v == nil {
		plain.Results = []Result{}
	}
	if plain.RunGuid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.RunGuid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "RunGuid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["taxonomies"]; !ok || v == nil {
		plain.Taxonomies = []ToolComponent{}
	}
	if v, ok := raw["threadFlowLocations"]; !ok || v == nil {
		plain.ThreadFlowLocations = []ThreadFlowLocation{}
	}
	if v, ok := raw["translations"]; !ok || v == nil {
		plain.Translations = []ToolComponent{}
	}
	if v, ok := raw["webRequests"]; !ok || v == nil {
		plain.WebRequests = []WebRequest{}
	}
	if v, ok := raw["webResponses"]; !ok || v == nil {
		plain.WebResponses = []WebResponse{}
	}
	*j = ExternalProperties(plain)
	return nil
}

// Contains information that enables a SARIF consumer to locate the external
// property file that contains the value of an externalized property associated
// with the run.
type ExternalPropertyFileReference interface{}

// References to external property files that should be inlined with the content of
// a root log file.
type ExternalPropertyFileReferences struct {
	// An array of external property files containing run.addresses arrays to be
	// merged with the root log file.
	Addresses []ExternalPropertyFileReference `json:"addresses,omitempty" yaml:"addresses,omitempty" mapstructure:"addresses,omitempty"`

	// An array of external property files containing run.artifacts arrays to be
	// merged with the root log file.
	Artifacts []ExternalPropertyFileReference `json:"artifacts,omitempty" yaml:"artifacts,omitempty" mapstructure:"artifacts,omitempty"`

	// An external property file containing a run.conversion object to be merged with
	// the root log file.
	Conversion ExternalPropertyFileReference `json:"conversion,omitempty" yaml:"conversion,omitempty" mapstructure:"conversion,omitempty"`

	// An external property file containing a run.driver object to be merged with the
	// root log file.
	Driver ExternalPropertyFileReference `json:"driver,omitempty" yaml:"driver,omitempty" mapstructure:"driver,omitempty"`

	// An array of external property files containing run.extensions arrays to be
	// merged with the root log file.
	Extensions []ExternalPropertyFileReference `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// An external property file containing a run.properties object to be merged with
	// the root log file.
	ExternalizedProperties ExternalPropertyFileReference `json:"externalizedProperties,omitempty" yaml:"externalizedProperties,omitempty" mapstructure:"externalizedProperties,omitempty"`

	// An array of external property files containing a run.graphs object to be merged
	// with the root log file.
	Graphs []ExternalPropertyFileReference `json:"graphs,omitempty" yaml:"graphs,omitempty" mapstructure:"graphs,omitempty"`

	// An array of external property files containing run.invocations arrays to be
	// merged with the root log file.
	Invocations []ExternalPropertyFileReference `json:"invocations,omitempty" yaml:"invocations,omitempty" mapstructure:"invocations,omitempty"`

	// An array of external property files containing run.logicalLocations arrays to
	// be merged with the root log file.
	LogicalLocations []ExternalPropertyFileReference `json:"logicalLocations,omitempty" yaml:"logicalLocations,omitempty" mapstructure:"logicalLocations,omitempty"`

	// An array of external property files containing run.policies arrays to be merged
	// with the root log file.
	Policies []ExternalPropertyFileReference `json:"policies,omitempty" yaml:"policies,omitempty" mapstructure:"policies,omitempty"`

	// Key/value pairs that provide additional information about the external property
	// files.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An array of external property files containing run.results arrays to be merged
	// with the root log file.
	Results []ExternalPropertyFileReference `json:"results,omitempty" yaml:"results,omitempty" mapstructure:"results,omitempty"`

	// An array of external property files containing run.taxonomies arrays to be
	// merged with the root log file.
	Taxonomies []ExternalPropertyFileReference `json:"taxonomies,omitempty" yaml:"taxonomies,omitempty" mapstructure:"taxonomies,omitempty"`

	// An array of external property files containing run.threadFlowLocations arrays
	// to be merged with the root log file.
	ThreadFlowLocations []ExternalPropertyFileReference `json:"threadFlowLocations,omitempty" yaml:"threadFlowLocations,omitempty" mapstructure:"threadFlowLocations,omitempty"`

	// An array of external property files containing run.translations arrays to be
	// merged with the root log file.
	Translations []ExternalPropertyFileReference `json:"translations,omitempty" yaml:"translations,omitempty" mapstructure:"translations,omitempty"`

	// An array of external property files containing run.requests arrays to be merged
	// with the root log file.
	WebRequests []ExternalPropertyFileReference `json:"webRequests,omitempty" yaml:"webRequests,omitempty" mapstructure:"webRequests,omitempty"`

	// An array of external property files containing run.responses arrays to be
	// merged with the root log file.
	WebResponses []ExternalPropertyFileReference `json:"webResponses,omitempty" yaml:"webResponses,omitempty" mapstructure:"webResponses,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalPropertyFileReferences) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain ExternalPropertyFileReferences
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["addresses"]; !ok || v == nil {
		plain.Addresses = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["artifacts"]; !ok || v == nil {
		plain.Artifacts = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["extensions"]; !ok || v == nil {
		plain.Extensions = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["graphs"]; !ok || v == nil {
		plain.Graphs = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["invocations"]; !ok || v == nil {
		plain.Invocations = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["logicalLocations"]; !ok || v == nil {
		plain.LogicalLocations = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["policies"]; !ok || v == nil {
		plain.Policies = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["results"]; !ok || v == nil {
		plain.Results = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["taxonomies"]; !ok || v == nil {
		plain.Taxonomies = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["threadFlowLocations"]; !ok || v == nil {
		plain.ThreadFlowLocations = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["translations"]; !ok || v == nil {
		plain.Translations = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["webRequests"]; !ok || v == nil {
		plain.WebRequests = []ExternalPropertyFileReference{}
	}
	if v, ok := raw["webResponses"]; !ok || v == nil {
		plain.WebResponses = []ExternalPropertyFileReference{}
	}
	*j = ExternalPropertyFileReferences(plain)
	return nil
}

// A proposed fix for the problem represented by a result object. A fix specifies a
// set of artifacts to modify. For each artifact, it specifies a set of bytes to
// remove, and provides a set of new bytes to replace them.
type Fix struct {
	// One or more artifact changes that comprise a fix for a result.
	ArtifactChanges []ArtifactChange `json:"artifactChanges" yaml:"artifactChanges" mapstructure:"artifactChanges"`

	// A message that describes the proposed fix, enabling viewers to present the
	// proposed change to an end user.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Key/value pairs that provide additional information about the fix.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Fix) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["artifactChanges"]; raw != nil && !ok {
		return fmt.Errorf("field artifactChanges in Fix: required")
	}
	type Plain Fix
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.ArtifactChanges != nil && len(plain.ArtifactChanges) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "artifactChanges", 1)
	}
	*j = Fix(plain)
	return nil
}

// A network of nodes and directed edges that describes some aspect of the
// structure of the code (for example, a call graph).
type Graph struct {
	// A description of the graph.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// An array of edge objects representing the edges of the graph.
	Edges []Edge `json:"edges,omitempty" yaml:"edges,omitempty" mapstructure:"edges,omitempty"`

	// An array of node objects representing the nodes of the graph.
	Nodes []Node `json:"nodes,omitempty" yaml:"nodes,omitempty" mapstructure:"nodes,omitempty"`

	// Key/value pairs that provide additional information about the graph.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// Represents a path through a graph.
type GraphTraversal struct {
	// A description of this graph traversal.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// The sequences of edges traversed by this graph traversal.
	EdgeTraversals []EdgeTraversal `json:"edgeTraversals,omitempty" yaml:"edgeTraversals,omitempty" mapstructure:"edgeTraversals,omitempty"`

	// Values of relevant expressions at the start of the graph traversal that remain
	// constant for the graph traversal.
	ImmutableState map[string]MultiformatMessageString `json:"immutableState,omitempty" yaml:"immutableState,omitempty" mapstructure:"immutableState,omitempty"`

	// Values of relevant expressions at the start of the graph traversal that may
	// change during graph traversal.
	InitialState map[string]MultiformatMessageString `json:"initialState,omitempty" yaml:"initialState,omitempty" mapstructure:"initialState,omitempty"`

	// Key/value pairs that provide additional information about the graph traversal.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The index within the result.graphs to be associated with the result.
	ResultGraphIndex int `json:"resultGraphIndex,omitempty" yaml:"resultGraphIndex,omitempty" mapstructure:"resultGraphIndex,omitempty"`

	// The index within the run.graphs to be associated with the result.
	RunGraphIndex int `json:"runGraphIndex,omitempty" yaml:"runGraphIndex,omitempty" mapstructure:"runGraphIndex,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GraphTraversal) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain GraphTraversal
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["edgeTraversals"]; !ok || v == nil {
		plain.EdgeTraversals = []EdgeTraversal{}
	}
	if v, ok := raw["resultGraphIndex"]; !ok || v == nil {
		plain.ResultGraphIndex = -1.0
	}
	if -1 > plain.ResultGraphIndex {
		return fmt.Errorf("field %s: must be >= %v", "resultGraphIndex", -1)
	}
	if v, ok := raw["runGraphIndex"]; !ok || v == nil {
		plain.RunGraphIndex = -1.0
	}
	if -1 > plain.RunGraphIndex {
		return fmt.Errorf("field %s: must be >= %v", "runGraphIndex", -1)
	}
	*j = GraphTraversal(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Graph) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain Graph
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["edges"]; !ok || v == nil {
		plain.Edges = []Edge{}
	}
	if v, ok := raw["nodes"]; !ok || v == nil {
		plain.Nodes = []Node{}
	}
	*j = Graph(plain)
	return nil
}

// The runtime environment of the analysis tool run.
type Invocation struct {
	// The account under which the invocation occurred.
	Account *string `json:"account,omitempty" yaml:"account,omitempty" mapstructure:"account,omitempty"`

	// An array of strings, containing in order the command line arguments passed to
	// the tool from the operating system.
	Arguments []string `json:"arguments,omitempty" yaml:"arguments,omitempty" mapstructure:"arguments,omitempty"`

	// The command line used to invoke the tool.
	CommandLine *string `json:"commandLine,omitempty" yaml:"commandLine,omitempty" mapstructure:"commandLine,omitempty"`

	// The Coordinated Universal Time (UTC) date and time at which the invocation
	// ended. See "Date/time properties" in the SARIF spec for the required format.
	EndTimeUtc *time.Time `json:"endTimeUtc,omitempty" yaml:"endTimeUtc,omitempty" mapstructure:"endTimeUtc,omitempty"`

	// The environment variables associated with the analysis tool process, expressed
	// as key/value pairs.
	EnvironmentVariables map[string]string `json:"environmentVariables,omitempty" yaml:"environmentVariables,omitempty" mapstructure:"environmentVariables,omitempty"`

	// An absolute URI specifying the location of the executable that was invoked.
	ExecutableLocation *ArtifactLocation `json:"executableLocation,omitempty" yaml:"executableLocation,omitempty" mapstructure:"executableLocation,omitempty"`

	// Specifies whether the tool's execution completed successfully.
	ExecutionSuccessful bool `json:"executionSuccessful" yaml:"executionSuccessful" mapstructure:"executionSuccessful"`

	// The process exit code.
	ExitCode *int `json:"exitCode,omitempty" yaml:"exitCode,omitempty" mapstructure:"exitCode,omitempty"`

	// The reason for the process exit.
	ExitCodeDescription *string `json:"exitCodeDescription,omitempty" yaml:"exitCodeDescription,omitempty" mapstructure:"exitCodeDescription,omitempty"`

	// The name of the signal that caused the process to exit.
	ExitSignalName *string `json:"exitSignalName,omitempty" yaml:"exitSignalName,omitempty" mapstructure:"exitSignalName,omitempty"`

	// The numeric value of the signal that caused the process to exit.
	ExitSignalNumber *int `json:"exitSignalNumber,omitempty" yaml:"exitSignalNumber,omitempty" mapstructure:"exitSignalNumber,omitempty"`

	// The machine on which the invocation occurred.
	Machine *string `json:"machine,omitempty" yaml:"machine,omitempty" mapstructure:"machine,omitempty"`

	// An array of configurationOverride objects that describe notifications related
	// runtime overrides.
	NotificationConfigurationOverrides []ConfigurationOverride `json:"notificationConfigurationOverrides,omitempty" yaml:"notificationConfigurationOverrides,omitempty" mapstructure:"notificationConfigurationOverrides,omitempty"`

	// The id of the process in which the invocation occurred.
	ProcessID *int `json:"processID,omitempty" yaml:"processID,omitempty" mapstructure:"processID,omitempty"`

	// The reason given by the operating system that the process failed to start.
	ProcessStartFailureMessage *string `json:"processStartFailureMessage,omitempty" yaml:"processStartFailureMessage,omitempty" mapstructure:"processStartFailureMessage,omitempty"`

	// Key/value pairs that provide additional information about the invocation.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The locations of any response files specified on the tool's command line.
	ResponseFiles []ArtifactLocation `json:"responseFiles,omitempty" yaml:"responseFiles,omitempty" mapstructure:"responseFiles,omitempty"`

	// An array of configurationOverride objects that describe rules related runtime
	// overrides.
	RuleConfigurationOverrides []ConfigurationOverride `json:"ruleConfigurationOverrides,omitempty" yaml:"ruleConfigurationOverrides,omitempty" mapstructure:"ruleConfigurationOverrides,omitempty"`

	// The Coordinated Universal Time (UTC) date and time at which the invocation
	// started. See "Date/time properties" in the SARIF spec for the required format.
	StartTimeUtc *time.Time `json:"startTimeUtc,omitempty" yaml:"startTimeUtc,omitempty" mapstructure:"startTimeUtc,omitempty"`

	// A file containing the standard error stream from the process that was invoked.
	Stderr *ArtifactLocation `json:"stderr,omitempty" yaml:"stderr,omitempty" mapstructure:"stderr,omitempty"`

	// A file containing the standard input stream to the process that was invoked.
	Stdin *ArtifactLocation `json:"stdin,omitempty" yaml:"stdin,omitempty" mapstructure:"stdin,omitempty"`

	// A file containing the standard output stream from the process that was invoked.
	Stdout *ArtifactLocation `json:"stdout,omitempty" yaml:"stdout,omitempty" mapstructure:"stdout,omitempty"`

	// A file containing the interleaved standard output and standard error stream
	// from the process that was invoked.
	StdoutStderr *ArtifactLocation `json:"stdoutStderr,omitempty" yaml:"stdoutStderr,omitempty" mapstructure:"stdoutStderr,omitempty"`

	// A list of conditions detected by the tool that are relevant to the tool's
	// configuration.
	ToolConfigurationNotifications []Notification `json:"toolConfigurationNotifications,omitempty" yaml:"toolConfigurationNotifications,omitempty" mapstructure:"toolConfigurationNotifications,omitempty"`

	// A list of runtime conditions detected by the tool during the analysis.
	ToolExecutionNotifications []Notification `json:"toolExecutionNotifications,omitempty" yaml:"toolExecutionNotifications,omitempty" mapstructure:"toolExecutionNotifications,omitempty"`

	// The working directory for the invocation.
	WorkingDirectory *ArtifactLocation `json:"workingDirectory,omitempty" yaml:"workingDirectory,omitempty" mapstructure:"workingDirectory,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Invocation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["executionSuccessful"]; raw != nil && !ok {
		return fmt.Errorf("field executionSuccessful in Invocation: required")
	}
	type Plain Invocation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["notificationConfigurationOverrides"]; !ok || v == nil {
		plain.NotificationConfigurationOverrides = []ConfigurationOverride{}
	}
	if v, ok := raw["ruleConfigurationOverrides"]; !ok || v == nil {
		plain.RuleConfigurationOverrides = []ConfigurationOverride{}
	}
	if v, ok := raw["toolConfigurationNotifications"]; !ok || v == nil {
		plain.ToolConfigurationNotifications = []Notification{}
	}
	if v, ok := raw["toolExecutionNotifications"]; !ok || v == nil {
		plain.ToolExecutionNotifications = []Notification{}
	}
	*j = Invocation(plain)
	return nil
}

// A location within a programming artifact.
type Location struct {
	// A set of regions relevant to the location.
	Annotations []Region `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Value that distinguishes this location from all other locations within a single
	// result object.
	ID int `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The logical locations associated with the result.
	LogicalLocations []LogicalLocation `json:"logicalLocations,omitempty" yaml:"logicalLocations,omitempty" mapstructure:"logicalLocations,omitempty"`

	// A message relevant to the location.
	Message Message `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// IDentifies the artifact and region.
	PhysicalLocation PhysicalLocation `json:"physicalLocation,omitempty" yaml:"physicalLocation,omitempty" mapstructure:"physicalLocation,omitempty"`

	// Key/value pairs that provide additional information about the location.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An array of objects that describe relationships between this location and
	// others.
	Relationships []LocationRelationship `json:"relationships,omitempty" yaml:"relationships,omitempty" mapstructure:"relationships,omitempty"`
}

// Information about the relation of one location to another.
type LocationRelationship struct {
	// A description of the location relationship.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// A set of distinct strings that categorize the relationship. Well-known kinds
	// include 'includes', 'isIncludedBy' and 'relevant'.
	Kinds []string `json:"kinds,omitempty" yaml:"kinds,omitempty" mapstructure:"kinds,omitempty"`

	// Key/value pairs that provide additional information about the location
	// relationship.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A reference to the related location.
	Target int `json:"target" yaml:"target" mapstructure:"target"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LocationRelationship) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in LocationRelationship: required")
	}
	type Plain LocationRelationship
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["kinds"]; !ok || v == nil {
		plain.Kinds = []string{
			"relevant",
		}
	}
	if 0 > plain.Target {
		return fmt.Errorf("field %s: must be >= %v", "target", 0)
	}
	*j = LocationRelationship(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Location) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain Location
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["annotations"]; !ok || v == nil {
		plain.Annotations = []Region{}
	}
	if v, ok := raw["id"]; !ok || v == nil {
		plain.ID = -1.0
	}
	if -1 > plain.ID {
		return fmt.Errorf("field %s: must be >= %v", "id", -1)
	}
	if v, ok := raw["logicalLocations"]; !ok || v == nil {
		plain.LogicalLocations = []LogicalLocation{}
	}
	if v, ok := raw["relationships"]; !ok || v == nil {
		plain.Relationships = []LocationRelationship{}
	}
	*j = Location(plain)
	return nil
}

// A logical location of a construct that produced a result.
type LogicalLocation struct {
	// The machine-readable name for the logical location, such as a mangled function
	// name provided by a C++ compiler that encodes calling convention, return type
	// and other details along with the function name.
	DecoratedName *string `json:"decoratedName,omitempty" yaml:"decoratedName,omitempty" mapstructure:"decoratedName,omitempty"`

	// The human-readable fully qualified name of the logical location.
	FullyQualifiedName *string `json:"fullyQualifiedName,omitempty" yaml:"fullyQualifiedName,omitempty" mapstructure:"fullyQualifiedName,omitempty"`

	// The index within the logical locations array.
	Index int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// The type of construct this logical location component refers to. Should be one
	// of 'function', 'member', 'module', 'namespace', 'parameter', 'resource',
	// 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value',
	// 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or
	// 'processingInstruction', if any of those accurately describe the construct.
	Kind *string `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// IDentifies the construct in which the result occurred. For example, this
	// property might contain the name of a class or a method.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// IDentifies the index of the immediate parent of the construct in which the
	// result was detected. For example, this property might point to a logical
	// location that represents the namespace that holds a type.
	ParentIndex int `json:"parentIndex,omitempty" yaml:"parentIndex,omitempty" mapstructure:"parentIndex,omitempty"`

	// Key/value pairs that provide additional information about the logical location.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LogicalLocation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain LogicalLocation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		plain.Index = -1.0
	}
	if -1 > plain.Index {
		return fmt.Errorf("field %s: must be >= %v", "index", -1)
	}
	if v, ok := raw["parentIndex"]; !ok || v == nil {
		plain.ParentIndex = -1.0
	}
	if -1 > plain.ParentIndex {
		return fmt.Errorf("field %s: must be >= %v", "parentIndex", -1)
	}
	*j = LogicalLocation(plain)
	return nil
}

// Encapsulates a message intended to be read by the end user.
type Message struct {
	Text string `json:"text" yaml:"text" mapstructure:"text"`
}

// A message string or message format string rendered in multiple formats.
type MultiformatMessageString struct {
	// A Markdown message string or format string.
	Markdown *string `json:"markdown,omitempty" yaml:"markdown,omitempty" mapstructure:"markdown,omitempty"`

	// Key/value pairs that provide additional information about the message.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A plain text message string or format string.
	Text string `json:"text" yaml:"text" mapstructure:"text"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MultiformatMessageString) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["text"]; raw != nil && !ok {
		return fmt.Errorf("field text in MultiformatMessageString: required")
	}
	type Plain MultiformatMessageString
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = MultiformatMessageString(plain)
	return nil
}

// Represents a node in a graph.
type Node struct {
	// Array of child nodes.
	Children []Node `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// A string that uniquely identifies the node within its graph.
	ID string `json:"id" yaml:"id" mapstructure:"id"`

	// A short description of the node.
	Label Message `json:"label,omitempty" yaml:"label,omitempty" mapstructure:"label,omitempty"`

	// A code location associated with the node.
	Location *Location `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Key/value pairs that provide additional information about the node.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Node) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Node: required")
	}
	type Plain Node
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["children"]; !ok || v == nil {
		plain.Children = []Node{}
	}
	*j = Node(plain)
	return nil
}

// Describes a condition relevant to the tool itself, as opposed to being relevant
// to a target being analyzed by the tool.
type Notification struct {
	// A reference used to locate the rule descriptor associated with this
	// notification.
	AssociatedRule ReportingDescriptorReference `json:"associatedRule,omitempty" yaml:"associatedRule,omitempty" mapstructure:"associatedRule,omitempty"`

	// A reference used to locate the descriptor relevant to this notification.
	Descriptor ReportingDescriptorReference `json:"descriptor,omitempty" yaml:"descriptor,omitempty" mapstructure:"descriptor,omitempty"`

	// The runtime exception, if any, relevant to this notification.
	Exception *Exception `json:"exception,omitempty" yaml:"exception,omitempty" mapstructure:"exception,omitempty"`

	// A value specifying the severity level of the notification.
	Level NotificationLevel `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// The locations relevant to this notification.
	Locations []Location `json:"locations,omitempty" yaml:"locations,omitempty" mapstructure:"locations,omitempty"`

	// A message that describes the condition that was encountered.
	Message Message `json:"message" yaml:"message" mapstructure:"message"`

	// Key/value pairs that provide additional information about the notification.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The thread identifier of the code that generated the notification.
	ThreadID *int `json:"threadID,omitempty" yaml:"threadID,omitempty" mapstructure:"threadID,omitempty"`

	// The Coordinated Universal Time (UTC) date and time at which the analysis tool
	// generated the notification.
	TimeUtc *time.Time `json:"timeUtc,omitempty" yaml:"timeUtc,omitempty" mapstructure:"timeUtc,omitempty"`
}

type NotificationLevel string

const NotificationLevelError NotificationLevel = "error"
const NotificationLevelNone NotificationLevel = "none"
const NotificationLevelNote NotificationLevel = "note"
const NotificationLevelWarning NotificationLevel = "warning"

var enumValues_NotificationLevel = []interface{}{
	"none",
	"note",
	"warning",
	"error",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotificationLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NotificationLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NotificationLevel, v)
	}
	*j = NotificationLevel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Notification) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in Notification: required")
	}
	type Plain Notification
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["level"]; !ok || v == nil {
		plain.Level = "warning"
	}
	if v, ok := raw["locations"]; !ok || v == nil {
		plain.Locations = []Location{}
	}
	*j = Notification(plain)
	return nil
}

// A physical location relevant to a result. Specifies a reference to a programming
// artifact together with a range of bytes or characters within that artifact.
type PhysicalLocation struct {
	Address *Address `json:"address,omitempty" yaml:"address,omitempty" mapstructure:"address,omitempty"`

	ArtifactLocation ArtifactLocation `json:"artifactLocation,omitempty" yaml:"artifactLocation,omitempty" mapstructure:"artifactLocation,omitempty"`

	Region *Region `json:"region,omitempty" yaml:"region,omitempty" mapstructure:"region,omitempty"`

	ContextRegion *Region `json:"contextRegion,omitempty" yaml:"contextRegion,omitempty" mapstructure:"contextRegion,omitempty"`

	// Key/value pairs that provide additional information about the physical
	// location.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// Key/value pairs that provide additional information about the object.
type PropertyBag struct {
	// A set of distinct strings that provide additional information.
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	AdditionalProperties map[string]any `mapstructure:",remain"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PropertyBag) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain PropertyBag
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["tags"]; !ok || v == nil {
		plain.Tags = []string{}
	}
	st := reflect.TypeOf(Plain{})
	for i := range st.NumField() {
		delete(raw, st.Field(i).Name)
		delete(raw, strings.Split(st.Field(i).Tag.Get("json"), ",")[0])
	}
	if err := mapstructure.Decode(raw, &plain.AdditionalProperties); err != nil {
		return err
	}
	*j = PropertyBag(plain)
	return nil
}

// An area within an image.
type Rectangle struct {
	// The Y coordinate of the bottom edge of the rectangle, measured in the image's
	// natural units.
	Bottom *float64 `json:"bottom,omitempty" yaml:"bottom,omitempty" mapstructure:"bottom,omitempty"`

	// The X coordinate of the left edge of the rectangle, measured in the image's
	// natural units.
	Left *float64 `json:"left,omitempty" yaml:"left,omitempty" mapstructure:"left,omitempty"`

	// A message relevant to the rectangle.
	Message Message `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Key/value pairs that provide additional information about the rectangle.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The X coordinate of the right edge of the rectangle, measured in the image's
	// natural units.
	Right *float64 `json:"right,omitempty" yaml:"right,omitempty" mapstructure:"right,omitempty"`

	// The Y coordinate of the top edge of the rectangle, measured in the image's
	// natural units.
	Top *float64 `json:"top,omitempty" yaml:"top,omitempty" mapstructure:"top,omitempty"`
}

// A region within an artifact where a result was detected.
type Region struct {
	StartLine *int `json:"startLine,omitempty" yaml:"startLine,omitempty" mapstructure:"startLine,omitempty"`

	StartColumn *int `json:"startColumn,omitempty" yaml:"startColumn,omitempty" mapstructure:"startColumn,omitempty"`

	EndLine *int `json:"endLine,omitempty" yaml:"endLine,omitempty" mapstructure:"endLine,omitempty"`

	EndColumn *int `json:"endColumn,omitempty" yaml:"endColumn,omitempty" mapstructure:"endColumn,omitempty"`

	// Key/value pairs that provide additional information about the region.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	Snippet *ArtifactContent `json:"snippet,omitempty" yaml:"snippet,omitempty" mapstructure:"snippet,omitempty"`
}

// The replacement of a single region of an artifact.
type Replacement struct {
	// The region of the artifact to delete.
	DeletedRegion Region `json:"deletedRegion" yaml:"deletedRegion" mapstructure:"deletedRegion"`

	// The content to insert at the location specified by the 'deletedRegion'
	// property.
	InsertedContent *ArtifactContent `json:"insertedContent,omitempty" yaml:"insertedContent,omitempty" mapstructure:"insertedContent,omitempty"`

	// Key/value pairs that provide additional information about the replacement.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Replacement) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["deletedRegion"]; raw != nil && !ok {
		return fmt.Errorf("field deletedRegion in Replacement: required")
	}
	type Plain Replacement
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Replacement(plain)
	return nil
}

// Information about a rule or notification that can be configured at runtime.
type ReportingConfiguration struct {
	// Specifies whether the report may be produced during the scan.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Specifies the failure level for the report.
	Level ReportingConfigurationLevel `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// Contains configuration information specific to a report.
	Parameters *PropertyBag `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// Key/value pairs that provide additional information about the reporting
	// configuration.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// Specifies the relative priority of the report. Used for analysis output only.
	Rank float64 `json:"rank,omitempty" yaml:"rank,omitempty" mapstructure:"rank,omitempty"`
}

type ReportingConfigurationLevel string

const ReportingConfigurationLevelError ReportingConfigurationLevel = "error"
const ReportingConfigurationLevelNone ReportingConfigurationLevel = "none"
const ReportingConfigurationLevelNote ReportingConfigurationLevel = "note"
const ReportingConfigurationLevelWarning ReportingConfigurationLevel = "warning"

var enumValues_ReportingConfigurationLevel = []interface{}{
	"none",
	"note",
	"warning",
	"error",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReportingConfigurationLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ReportingConfigurationLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ReportingConfigurationLevel, v)
	}
	*j = ReportingConfigurationLevel(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReportingConfiguration) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain ReportingConfiguration
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = true
	}
	if v, ok := raw["level"]; !ok || v == nil {
		plain.Level = "warning"
	}
	if v, ok := raw["rank"]; !ok || v == nil {
		plain.Rank = -1.0
	}
	if 100 < plain.Rank {
		return fmt.Errorf("field %s: must be <= %v", "rank", 100)
	}
	if -1 > plain.Rank {
		return fmt.Errorf("field %s: must be >= %v", "rank", -1)
	}
	*j = ReportingConfiguration(plain)
	return nil
}

// Metadata that describes a specific report produced by the tool, as part of the
// analysis it provides or its runtime reporting.
type ReportingDescriptor struct {
	// Default reporting configuration information.
	DefaultConfiguration *ReportingConfiguration `json:"defaultConfiguration,omitempty" yaml:"defaultConfiguration,omitempty" mapstructure:"defaultConfiguration,omitempty"`

	// An array of unique identifies in the form of a GUID by which this report was
	// known in some previous version of the analysis tool.
	DeprecatedGuids []string `json:"deprecatedGuids,omitempty" yaml:"deprecatedGuids,omitempty" mapstructure:"deprecatedGuids,omitempty"`

	// An array of stable, opaque identifiers by which this report was known in some
	// previous version of the analysis tool.
	DeprecatedIDs []string `json:"deprecatedIDs,omitempty" yaml:"deprecatedIDs,omitempty" mapstructure:"deprecatedIDs,omitempty"`

	// An array of readable identifiers by which this report was known in some
	// previous version of the analysis tool.
	DeprecatedNames []string `json:"deprecatedNames,omitempty" yaml:"deprecatedNames,omitempty" mapstructure:"deprecatedNames,omitempty"`

	// A description of the report. Should, as far as possible, provide details
	// sufficient to enable resolution of any problem indicated by the result.
	FullDescription *MultiformatMessageString `json:"fullDescription,omitempty" yaml:"fullDescription,omitempty" mapstructure:"fullDescription,omitempty"`

	// A unique identifier for the reporting descriptor in the form of a GUID.
	Guid *string `json:"guid,omitempty" yaml:"guid,omitempty" mapstructure:"guid,omitempty"`

	// Provides the primary documentation for the report, useful when there is no
	// online documentation.
	Help *MultiformatMessageString `json:"help,omitempty" yaml:"help,omitempty" mapstructure:"help,omitempty"`

	// A URI where the primary documentation for the report can be found.
	HelpURI *string `json:"helpURI,omitempty" yaml:"helpURI,omitempty" mapstructure:"helpURI,omitempty"`

	// A stable, opaque identifier for the report.
	ID string `json:"id" yaml:"id" mapstructure:"id"`

	// A set of name/value pairs with arbitrary names. Each value is a
	// multiformatMessageString object, which holds message strings in plain text and
	// (optionally) Markdown format. The strings can include placeholders, which can
	// be used to construct a message in combination with an arbitrary number of
	// additional string arguments.
	MessageStrings map[string]MultiformatMessageString `json:"messageStrings,omitempty" yaml:"messageStrings,omitempty" mapstructure:"messageStrings,omitempty"`

	// A report identifier that is understandable to an end user.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Key/value pairs that provide additional information about the report.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An array of objects that describe relationships between this reporting
	// descriptor and others.
	Relationships []ReportingDescriptorRelationship `json:"relationships,omitempty" yaml:"relationships,omitempty" mapstructure:"relationships,omitempty"`

	// A concise description of the report. Should be a single sentence that is
	// understandable when visible space is limited to a single line of text.
	ShortDescription *MultiformatMessageString `json:"shortDescription,omitempty" yaml:"shortDescription,omitempty" mapstructure:"shortDescription,omitempty"`
}

// Information about how to locate a relevant reporting descriptor.
type ReportingDescriptorReference interface{}

// Information about the relation of one reporting descriptor to another.
type ReportingDescriptorRelationship struct {
	// A description of the reporting descriptor relationship.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// A set of distinct strings that categorize the relationship. Well-known kinds
	// include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset',
	// 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.
	Kinds []string `json:"kinds,omitempty" yaml:"kinds,omitempty" mapstructure:"kinds,omitempty"`

	// Key/value pairs that provide additional information about the reporting
	// descriptor reference.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A reference to the related reporting descriptor.
	Target ReportingDescriptorReference `json:"target" yaml:"target" mapstructure:"target"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReportingDescriptorRelationship) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["target"]; raw != nil && !ok {
		return fmt.Errorf("field target in ReportingDescriptorRelationship: required")
	}
	type Plain ReportingDescriptorRelationship
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["kinds"]; !ok || v == nil {
		plain.Kinds = []string{
			"relevant",
		}
	}
	*j = ReportingDescriptorRelationship(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ReportingDescriptor) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in ReportingDescriptor: required")
	}
	type Plain ReportingDescriptor
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Guid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.Guid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Guid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["relationships"]; !ok || v == nil {
		plain.Relationships = []ReportingDescriptorRelationship{}
	}
	*j = ReportingDescriptor(plain)
	return nil
}

// A result produced by an analysis tool.
type Result struct {
	// IDentifies the artifact that the analysis tool was instructed to scan. This
	// need not be the same as the artifact where the result actually occurred.
	AnalysisTarget *ArtifactLocation `json:"analysisTarget,omitempty" yaml:"analysisTarget,omitempty" mapstructure:"analysisTarget,omitempty"`

	// A set of artifacts relevant to the result.
	Attachments []Attachment `json:"attachments,omitempty" yaml:"attachments,omitempty" mapstructure:"attachments,omitempty"`

	// The state of a result relative to a baseline of a previous run.
	BaselineState *ResultBaselineState `json:"baselineState,omitempty" yaml:"baselineState,omitempty" mapstructure:"baselineState,omitempty"`

	// An array of 'codeFlow' objects relevant to the result.
	CodeFlows []CodeFlow `json:"codeFlows,omitempty" yaml:"codeFlows,omitempty" mapstructure:"codeFlows,omitempty"`

	// A stable, unique identifier for the equivalence class of logically identical
	// results to which this result belongs, in the form of a GUID.
	CorrelationGuid *string `json:"correlationGuid,omitempty" yaml:"correlationGuid,omitempty" mapstructure:"correlationGuid,omitempty"`

	// A set of strings each of which individually defines a stable, unique identity
	// for the result.
	Fingerprints map[string]string `json:"fingerprints,omitempty" yaml:"fingerprints,omitempty" mapstructure:"fingerprints,omitempty"`

	// An array of 'fix' objects, each of which represents a proposed fix to the
	// problem indicated by the result.
	Fixes []Fix `json:"fixes,omitempty" yaml:"fixes,omitempty" mapstructure:"fixes,omitempty"`

	// An array of one or more unique 'graphTraversal' objects.
	GraphTraversals []GraphTraversal `json:"graphTraversals,omitempty" yaml:"graphTraversals,omitempty" mapstructure:"graphTraversals,omitempty"`

	// An array of zero or more unique graph objects associated with the result.
	Graphs []Graph `json:"graphs,omitempty" yaml:"graphs,omitempty" mapstructure:"graphs,omitempty"`

	// A stable, unique identifier for the result in the form of a GUID.
	Guid *string `json:"guid,omitempty" yaml:"guid,omitempty" mapstructure:"guid,omitempty"`

	// An absolute URI at which the result can be viewed.
	HostedViewerURI *string `json:"hostedViewerURI,omitempty" yaml:"hostedViewerURI,omitempty" mapstructure:"hostedViewerURI,omitempty"`

	// A value that categorizes results by evaluation state.
	Kind ResultKind `json:"kind,omitempty" yaml:"kind,omitempty" mapstructure:"kind,omitempty"`

	// A value specifying the severity level of the result.
	Level ResultLevel `json:"level,omitempty" yaml:"level,omitempty" mapstructure:"level,omitempty"`

	// The set of locations where the result was detected. Specify only one location
	// unless the problem indicated by the result can only be corrected by making a
	// change at every specified location.
	Locations []Location `json:"locations,omitempty" yaml:"locations,omitempty" mapstructure:"locations,omitempty"`

	// A message that describes the result. The first sentence of the message only
	// will be displayed when visible space is limited.
	Message Message `json:"message" yaml:"message" mapstructure:"message"`

	// A positive integer specifying the number of times this logically unique result
	// was observed in this run.
	OccurrenceCount *int `json:"occurrenceCount,omitempty" yaml:"occurrenceCount,omitempty" mapstructure:"occurrenceCount,omitempty"`

	// A set of strings that contribute to the stable, unique identity of the result.
	PartialFingerprints map[string]string `json:"partialFingerprints,omitempty" yaml:"partialFingerprints,omitempty" mapstructure:"partialFingerprints,omitempty"`

	// Key/value pairs that provide additional information about the result.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// Information about how and when the result was detected.
	Provenance *ResultProvenance `json:"provenance,omitempty" yaml:"provenance,omitempty" mapstructure:"provenance,omitempty"`

	// A number representing the priority or importance of the result.
	Rank float64 `json:"rank,omitempty" yaml:"rank,omitempty" mapstructure:"rank,omitempty"`

	// A set of locations relevant to this result.
	RelatedLocations []Location `json:"relatedLocations,omitempty" yaml:"relatedLocations,omitempty" mapstructure:"relatedLocations,omitempty"`

	// A reference used to locate the rule descriptor relevant to this result.
	Rule ReportingDescriptorReference `json:"rule,omitempty" yaml:"rule,omitempty" mapstructure:"rule,omitempty"`

	// The stable, unique identifier of the rule, if any, to which this result is
	// relevant.
	RuleID *string `json:"ruleID,omitempty" yaml:"ruleID,omitempty" mapstructure:"ruleID,omitempty"`

	// The index within the tool component rules array of the rule object associated
	// with this result.
	RuleIndex int `json:"ruleIndex,omitempty" yaml:"ruleIndex,omitempty" mapstructure:"ruleIndex,omitempty"`

	// An array of 'stack' objects relevant to the result.
	Stacks []Stack `json:"stacks,omitempty" yaml:"stacks,omitempty" mapstructure:"stacks,omitempty"`

	// A set of suppressions relevant to this result.
	Suppressions []Suppression `json:"suppressions,omitempty" yaml:"suppressions,omitempty" mapstructure:"suppressions,omitempty"`

	// An array of references to taxonomy reporting descriptors that are applicable to
	// the result.
	Taxa []ReportingDescriptorReference `json:"taxa,omitempty" yaml:"taxa,omitempty" mapstructure:"taxa,omitempty"`

	// A web request associated with this result.
	WebRequest *WebRequest `json:"webRequest,omitempty" yaml:"webRequest,omitempty" mapstructure:"webRequest,omitempty"`

	// A web response associated with this result.
	WebResponse *WebResponse `json:"webResponse,omitempty" yaml:"webResponse,omitempty" mapstructure:"webResponse,omitempty"`

	// The URIs of the work items associated with this result.
	WorkItemURIs []string `json:"workItemURIs,omitempty" yaml:"workItemURIs,omitempty" mapstructure:"workItemURIs,omitempty"`
}

type ResultBaselineState string

const ResultBaselineStateAbsent ResultBaselineState = "absent"
const ResultBaselineStateNew ResultBaselineState = "new"
const ResultBaselineStateUnchanged ResultBaselineState = "unchanged"
const ResultBaselineStateUpdated ResultBaselineState = "updated"

var enumValues_ResultBaselineState = []interface{}{
	"new",
	"unchanged",
	"updated",
	"absent",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResultBaselineState) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResultBaselineState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResultBaselineState, v)
	}
	*j = ResultBaselineState(v)
	return nil
}

type ResultKind string

const ResultKindFail ResultKind = "fail"
const ResultKindInformational ResultKind = "informational"
const ResultKindNotApplicable ResultKind = "notApplicable"
const ResultKindOpen ResultKind = "open"
const ResultKindPass ResultKind = "pass"
const ResultKindReview ResultKind = "review"

var enumValues_ResultKind = []interface{}{
	"notApplicable",
	"pass",
	"fail",
	"review",
	"open",
	"informational",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResultKind) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResultKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResultKind, v)
	}
	*j = ResultKind(v)
	return nil
}

type ResultLevel string

const ResultLevelError ResultLevel = "error"
const ResultLevelNone ResultLevel = "none"
const ResultLevelNote ResultLevel = "note"
const ResultLevelWarning ResultLevel = "warning"

var enumValues_ResultLevel = []interface{}{
	"none",
	"note",
	"warning",
	"error",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResultLevel) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ResultLevel {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ResultLevel, v)
	}
	*j = ResultLevel(v)
	return nil
}

// Contains information about how and when a result was detected.
type ResultProvenance struct {
	// An array of physicalLocation objects which specify the portions of an analysis
	// tool's output that a converter transformed into the result.
	ConversionSources []PhysicalLocation `json:"conversionSources,omitempty" yaml:"conversionSources,omitempty" mapstructure:"conversionSources,omitempty"`

	// A GUID-valued string equal to the automationDetails.guid property of the run in
	// which the result was first detected.
	FirstDetectionRunGuid *string `json:"firstDetectionRunGuid,omitempty" yaml:"firstDetectionRunGuid,omitempty" mapstructure:"firstDetectionRunGuid,omitempty"`

	// The Coordinated Universal Time (UTC) date and time at which the result was
	// first detected. See "Date/time properties" in the SARIF spec for the required
	// format.
	FirstDetectionTimeUtc *time.Time `json:"firstDetectionTimeUtc,omitempty" yaml:"firstDetectionTimeUtc,omitempty" mapstructure:"firstDetectionTimeUtc,omitempty"`

	// The index within the run.invocations array of the invocation object which
	// describes the tool invocation that detected the result.
	InvocationIndex int `json:"invocationIndex,omitempty" yaml:"invocationIndex,omitempty" mapstructure:"invocationIndex,omitempty"`

	// A GUID-valued string equal to the automationDetails.guid property of the run in
	// which the result was most recently detected.
	LastDetectionRunGuid *string `json:"lastDetectionRunGuid,omitempty" yaml:"lastDetectionRunGuid,omitempty" mapstructure:"lastDetectionRunGuid,omitempty"`

	// The Coordinated Universal Time (UTC) date and time at which the result was most
	// recently detected. See "Date/time properties" in the SARIF spec for the
	// required format.
	LastDetectionTimeUtc *time.Time `json:"lastDetectionTimeUtc,omitempty" yaml:"lastDetectionTimeUtc,omitempty" mapstructure:"lastDetectionTimeUtc,omitempty"`

	// Key/value pairs that provide additional information about the result.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResultProvenance) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain ResultProvenance
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["conversionSources"]; !ok || v == nil {
		plain.ConversionSources = []PhysicalLocation{}
	}
	if plain.FirstDetectionRunGuid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.FirstDetectionRunGuid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "FirstDetectionRunGuid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["invocationIndex"]; !ok || v == nil {
		plain.InvocationIndex = -1.0
	}
	if -1 > plain.InvocationIndex {
		return fmt.Errorf("field %s: must be >= %v", "invocationIndex", -1)
	}
	if plain.LastDetectionRunGuid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.LastDetectionRunGuid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "LastDetectionRunGuid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	*j = ResultProvenance(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Result) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["message"]; raw != nil && !ok {
		return fmt.Errorf("field message in Result: required")
	}
	type Plain Result
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["attachments"]; !ok || v == nil {
		plain.Attachments = []Attachment{}
	}
	if v, ok := raw["codeFlows"]; !ok || v == nil {
		plain.CodeFlows = []CodeFlow{}
	}
	if plain.CorrelationGuid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.CorrelationGuid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CorrelationGuid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["fixes"]; !ok || v == nil {
		plain.Fixes = []Fix{}
	}
	if v, ok := raw["graphTraversals"]; !ok || v == nil {
		plain.GraphTraversals = []GraphTraversal{}
	}
	if v, ok := raw["graphs"]; !ok || v == nil {
		plain.Graphs = []Graph{}
	}
	if plain.Guid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.Guid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Guid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["kind"]; !ok || v == nil {
		plain.Kind = "fail"
	}
	if v, ok := raw["level"]; !ok || v == nil {
		plain.Level = "warning"
	}
	if v, ok := raw["locations"]; !ok || v == nil {
		plain.Locations = []Location{}
	}
	if plain.OccurrenceCount != nil && 1 > *plain.OccurrenceCount {
		return fmt.Errorf("field %s: must be >= %v", "occurrenceCount", 1)
	}
	if v, ok := raw["rank"]; !ok || v == nil {
		plain.Rank = -1.0
	}
	if 100 < plain.Rank {
		return fmt.Errorf("field %s: must be <= %v", "rank", 100)
	}
	if -1 > plain.Rank {
		return fmt.Errorf("field %s: must be >= %v", "rank", -1)
	}
	if v, ok := raw["relatedLocations"]; !ok || v == nil {
		plain.RelatedLocations = []Location{}
	}
	if v, ok := raw["ruleIndex"]; !ok || v == nil {
		plain.RuleIndex = -1.0
	}
	if -1 > plain.RuleIndex {
		return fmt.Errorf("field %s: must be >= %v", "ruleIndex", -1)
	}
	if v, ok := raw["stacks"]; !ok || v == nil {
		plain.Stacks = []Stack{}
	}
	if v, ok := raw["taxa"]; !ok || v == nil {
		plain.Taxa = []ReportingDescriptorReference{}
	}
	*j = Result(plain)
	return nil
}

// Describes a single run of an analysis tool, and contains the reported output of
// that run.
type Run struct {
	// Addresses associated with this run instance, if any.
	Addresses []Address `json:"addresses,omitempty" yaml:"addresses,omitempty" mapstructure:"addresses,omitempty"`

	// An array of artifact objects relevant to the run.
	Artifacts []Artifact `json:"artifacts,omitempty" yaml:"artifacts,omitempty" mapstructure:"artifacts,omitempty"`

	// Automation details that describe this run.
	AutomationDetails *RunAutomationDetails `json:"automationDetails,omitempty" yaml:"automationDetails,omitempty" mapstructure:"automationDetails,omitempty"`

	// The 'guid' property of a previous SARIF 'run' that comprises the baseline that
	// was used to compute result 'baselineState' properties for the run.
	BaselineGuid *string `json:"baselineGuid,omitempty" yaml:"baselineGuid,omitempty" mapstructure:"baselineGuid,omitempty"`

	// Specifies the unit in which the tool measures columns.
	ColumnKind *RunColumnKind `json:"columnKind,omitempty" yaml:"columnKind,omitempty" mapstructure:"columnKind,omitempty"`

	// A conversion object that describes how a converter transformed an analysis
	// tool's native reporting format into the SARIF format.
	Conversion *Conversion `json:"conversion,omitempty" yaml:"conversion,omitempty" mapstructure:"conversion,omitempty"`

	// Specifies the default encoding for any artifact object that refers to a text
	// file.
	DefaultEncoding *string `json:"defaultEncoding,omitempty" yaml:"defaultEncoding,omitempty" mapstructure:"defaultEncoding,omitempty"`

	// Specifies the default source language for any artifact object that refers to a
	// text file that contains source code.
	DefaultSourceLanguage *string `json:"defaultSourceLanguage,omitempty" yaml:"defaultSourceLanguage,omitempty" mapstructure:"defaultSourceLanguage,omitempty"`

	// References to external property files that should be inlined with the content
	// of a root log file.
	ExternalPropertyFileReferences *ExternalPropertyFileReferences `json:"externalPropertyFileReferences,omitempty" yaml:"externalPropertyFileReferences,omitempty" mapstructure:"externalPropertyFileReferences,omitempty"`

	// An array of zero or more unique graph objects associated with the run.
	Graphs []Graph `json:"graphs,omitempty" yaml:"graphs,omitempty" mapstructure:"graphs,omitempty"`

	// Describes the invocation of the analysis tool.
	Invocations []Invocation `json:"invocations,omitempty" yaml:"invocations,omitempty" mapstructure:"invocations,omitempty"`

	// The language of the messages emitted into the log file during this run
	// (expressed as an ISO 639-1 two-letter lowercase culture code) and an optional
	// region (expressed as an ISO 3166-1 two-letter uppercase subculture code
	// associated with a country or region). The casing is recommended but not
	// required (in order for this data to conform to RFC5646).
	Language string `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`

	// An array of logical locations such as namespaces, types or functions.
	LogicalLocations []LogicalLocation `json:"logicalLocations,omitempty" yaml:"logicalLocations,omitempty" mapstructure:"logicalLocations,omitempty"`

	// An ordered list of character sequences that were treated as line breaks when
	// computing region information for the run.
	NewlineSequences []string `json:"newlineSequences,omitempty" yaml:"newlineSequences,omitempty" mapstructure:"newlineSequences,omitempty"`

	// The artifact location specified by each uriBaseID symbol on the machine where
	// the tool originally ran.
	OriginalURIBaseIDs map[string]ArtifactLocation `json:"originalURIBaseIDs,omitempty" yaml:"originalURIBaseIDs,omitempty" mapstructure:"originalURIBaseIDs,omitempty"`

	// Contains configurations that may potentially override both
	// reportingDescriptor.defaultConfiguration (the tool's default severities) and
	// invocation.configurationOverrides (severities established at run-time from the
	// command line).
	Policies []ToolComponent `json:"policies,omitempty" yaml:"policies,omitempty" mapstructure:"policies,omitempty"`

	// Key/value pairs that provide additional information about the run.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// An array of strings used to replace sensitive information in a redaction-aware
	// property.
	RedactionTokens []string `json:"redactionTokens,omitempty" yaml:"redactionTokens,omitempty" mapstructure:"redactionTokens,omitempty"`

	// The set of results contained in an SARIF log. The results array can be omitted
	// when a run is solely exporting rules metadata. It must be present (but may be
	// empty) if a log file represents an actual scan.
	Results []Result `json:"results,omitempty" yaml:"results,omitempty" mapstructure:"results,omitempty"`

	// Automation details that describe the aggregate of runs to which this run
	// belongs.
	RunAggregates []RunAutomationDetails `json:"runAggregates,omitempty" yaml:"runAggregates,omitempty" mapstructure:"runAggregates,omitempty"`

	// A specialLocations object that defines locations of special significance to
	// SARIF consumers.
	SpecialLocations *SpecialLocations `json:"specialLocations,omitempty" yaml:"specialLocations,omitempty" mapstructure:"specialLocations,omitempty"`

	// An array of toolComponent objects relevant to a taxonomy in which results are
	// categorized.
	Taxonomies []ToolComponent `json:"taxonomies,omitempty" yaml:"taxonomies,omitempty" mapstructure:"taxonomies,omitempty"`

	// An array of threadFlowLocation objects cached at run level.
	ThreadFlowLocations []ThreadFlowLocation `json:"threadFlowLocations,omitempty" yaml:"threadFlowLocations,omitempty" mapstructure:"threadFlowLocations,omitempty"`

	// Information about the tool or tool pipeline that generated the results in this
	// run. A run can only contain results produced by a single tool or tool pipeline.
	// A run can aggregate results from multiple log files, as long as context around
	// the tool run (tool command-line arguments and the like) is identical for all
	// aggregated files.
	Tool Tool `json:"tool" yaml:"tool" mapstructure:"tool"`

	// The set of available translations of the localized data provided by the tool.
	Translations []ToolComponent `json:"translations,omitempty" yaml:"translations,omitempty" mapstructure:"translations,omitempty"`

	// Specifies the revision in version control of the artifacts that were scanned.
	VersionControlProvenance []VersionControlDetails `json:"versionControlProvenance,omitempty" yaml:"versionControlProvenance,omitempty" mapstructure:"versionControlProvenance,omitempty"`

	// An array of request objects cached at run level.
	WebRequests []WebRequest `json:"webRequests,omitempty" yaml:"webRequests,omitempty" mapstructure:"webRequests,omitempty"`

	// An array of response objects cached at run level.
	WebResponses []WebResponse `json:"webResponses,omitempty" yaml:"webResponses,omitempty" mapstructure:"webResponses,omitempty"`
}

// Information that describes a run's identity and role within an engineering
// system process.
type RunAutomationDetails struct {
	// A stable, unique identifier for the equivalence class of runs to which this
	// object's containing run object belongs in the form of a GUID.
	CorrelationGuid *string `json:"correlationGuid,omitempty" yaml:"correlationGuid,omitempty" mapstructure:"correlationGuid,omitempty"`

	// A description of the identity and role played within the engineering system by
	// this object's containing run object.
	Description Message `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// A stable, unique identifier for this object's containing run object in the form
	// of a GUID.
	Guid *string `json:"guid,omitempty" yaml:"guid,omitempty" mapstructure:"guid,omitempty"`

	// A hierarchical string that uniquely identifies this object's containing run
	// object.
	ID *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Key/value pairs that provide additional information about the run automation
	// details.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RunAutomationDetails) UnmarshalJSON(value []byte) error {
	type Plain RunAutomationDetails
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.CorrelationGuid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.CorrelationGuid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "CorrelationGuid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if plain.Guid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.Guid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Guid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	*j = RunAutomationDetails(plain)
	return nil
}

type RunColumnKind string

const RunColumnKindUnicodeCodePoints RunColumnKind = "unicodeCodePoints"
const RunColumnKindUtf16CodeUnits RunColumnKind = "utf16CodeUnits"

var enumValues_RunColumnKind = []interface{}{
	"utf16CodeUnits",
	"unicodeCodePoints",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RunColumnKind) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RunColumnKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RunColumnKind, v)
	}
	*j = RunColumnKind(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Run) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["tool"]; raw != nil && !ok {
		return fmt.Errorf("field tool in Run: required")
	}
	type Plain Run
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["addresses"]; !ok || v == nil {
		plain.Addresses = []Address{}
	}
	if plain.BaselineGuid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.BaselineGuid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "BaselineGuid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["graphs"]; !ok || v == nil {
		plain.Graphs = []Graph{}
	}
	if v, ok := raw["invocations"]; !ok || v == nil {
		plain.Invocations = []Invocation{}
	}
	if v, ok := raw["language"]; !ok || v == nil {
		plain.Language = "en-US"
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z]{2}(-[a-zA-Z]{2})?$`, string(plain.Language)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Language", `^[a-zA-Z]{2}(-[a-zA-Z]{2})?$`)
	}
	if v, ok := raw["logicalLocations"]; !ok || v == nil {
		plain.LogicalLocations = []LogicalLocation{}
	}
	if v, ok := raw["newlineSequences"]; !ok || v == nil {
		plain.NewlineSequences = []string{
			"\r\n",
			"\n",
		}
	}
	if plain.NewlineSequences != nil && len(plain.NewlineSequences) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "newlineSequences", 1)
	}
	if v, ok := raw["policies"]; !ok || v == nil {
		plain.Policies = []ToolComponent{}
	}
	if v, ok := raw["redactionTokens"]; !ok || v == nil {
		plain.RedactionTokens = []string{}
	}
	if v, ok := raw["runAggregates"]; !ok || v == nil {
		plain.RunAggregates = []RunAutomationDetails{}
	}
	if v, ok := raw["taxonomies"]; !ok || v == nil {
		plain.Taxonomies = []ToolComponent{}
	}
	if v, ok := raw["threadFlowLocations"]; !ok || v == nil {
		plain.ThreadFlowLocations = []ThreadFlowLocation{}
	}
	if v, ok := raw["translations"]; !ok || v == nil {
		plain.Translations = []ToolComponent{}
	}
	if v, ok := raw["versionControlProvenance"]; !ok || v == nil {
		plain.VersionControlProvenance = []VersionControlDetails{}
	}
	if v, ok := raw["webRequests"]; !ok || v == nil {
		plain.WebRequests = []WebRequest{}
	}
	if v, ok := raw["webResponses"]; !ok || v == nil {
		plain.WebResponses = []WebResponse{}
	}
	*j = Run(plain)
	return nil
}

// Static Analysis Results Format (SARIF) Version 2.1.0 JSON Schema: a standard
// format for the output of static analysis tools.
type SarifSchema210Json struct {
	// The URI of the JSON schema corresponding to the version.
	Schema *string `json:"$schema,omitempty" yaml:"$schema,omitempty" mapstructure:"$schema,omitempty"`

	// References to external property files that share data between runs.
	InlineExternalProperties []ExternalProperties `json:"inlineExternalProperties,omitempty" yaml:"inlineExternalProperties,omitempty" mapstructure:"inlineExternalProperties,omitempty"`

	// Key/value pairs that provide additional information about the log file.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The set of runs contained in this log file.
	Runs []Run `json:"runs" yaml:"runs" mapstructure:"runs"`

	// The SARIF format version of this log file.
	Version SarifSchema210JsonVersion `json:"version" yaml:"version" mapstructure:"version"`
}

type SarifSchema210JsonVersion string

const SarifSchema210JsonVersionA210 SarifSchema210JsonVersion = "2.1.0"

var enumValues_SarifSchema210JsonVersion = []interface{}{
	"2.1.0",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SarifSchema210JsonVersion) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SarifSchema210JsonVersion {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SarifSchema210JsonVersion, v)
	}
	*j = SarifSchema210JsonVersion(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SarifSchema210Json) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["runs"]; raw != nil && !ok {
		return fmt.Errorf("field runs in SarifSchema210Json: required")
	}
	if _, ok := raw["version"]; raw != nil && !ok {
		return fmt.Errorf("field version in SarifSchema210Json: required")
	}
	type Plain SarifSchema210Json
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = SarifSchema210Json(plain)
	return nil
}

// Defines locations of special significance to SARIF consumers.
type SpecialLocations struct {
	// Provides a suggestion to SARIF consumers to display file paths relative to the
	// specified location.
	DisplayBase *ArtifactLocation `json:"displayBase,omitempty" yaml:"displayBase,omitempty" mapstructure:"displayBase,omitempty"`

	// Key/value pairs that provide additional information about the special
	// locations.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// A call stack that is relevant to a result.
type Stack struct {
	// An array of stack frames that represents a sequence of calls, rendered in
	// reverse chronological order, that comprise the call stack.
	Frames []StackFrame `json:"frames" yaml:"frames" mapstructure:"frames"`

	// A message relevant to this call stack.
	Message Message `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Key/value pairs that provide additional information about the stack.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// A function call within a stack trace.
type StackFrame struct {
	// The location to which this stack frame refers.
	Location *Location `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// The name of the module that contains the code of this stack frame.
	Module *string `json:"module,omitempty" yaml:"module,omitempty" mapstructure:"module,omitempty"`

	// The parameters of the call that is executing.
	Parameters []string `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// Key/value pairs that provide additional information about the stack frame.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The thread identifier of the stack frame.
	ThreadID *int `json:"threadID,omitempty" yaml:"threadID,omitempty" mapstructure:"threadID,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StackFrame) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain StackFrame
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["parameters"]; !ok || v == nil {
		plain.Parameters = []string{}
	}
	*j = StackFrame(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Stack) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["frames"]; raw != nil && !ok {
		return fmt.Errorf("field frames in Stack: required")
	}
	type Plain Stack
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Stack(plain)
	return nil
}

// A suppression that is relevant to a result.
type Suppression struct {
	// A stable, unique identifier for the suprression in the form of a GUID.
	Guid *string `json:"guid,omitempty" yaml:"guid,omitempty" mapstructure:"guid,omitempty"`

	// A string representing the justification for the suppression.
	Justification *string `json:"justification,omitempty" yaml:"justification,omitempty" mapstructure:"justification,omitempty"`

	// A string that indicates where the suppression is persisted.
	Kind SuppressionKind `json:"kind" yaml:"kind" mapstructure:"kind"`

	// IDentifies the location associated with the suppression.
	Location *Location `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// Key/value pairs that provide additional information about the suppression.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A string that indicates the review status of the suppression.
	Status *SuppressionStatus `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`
}

type SuppressionKind string

const SuppressionKindExternal SuppressionKind = "external"
const SuppressionKindInSource SuppressionKind = "inSource"

var enumValues_SuppressionKind = []interface{}{
	"inSource",
	"external",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SuppressionKind) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SuppressionKind {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SuppressionKind, v)
	}
	*j = SuppressionKind(v)
	return nil
}

type SuppressionStatus string

const SuppressionStatusAccepted SuppressionStatus = "accepted"
const SuppressionStatusRejected SuppressionStatus = "rejected"
const SuppressionStatusUnderReview SuppressionStatus = "underReview"

var enumValues_SuppressionStatus = []interface{}{
	"accepted",
	"underReview",
	"rejected",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SuppressionStatus) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SuppressionStatus {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SuppressionStatus, v)
	}
	*j = SuppressionStatus(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Suppression) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in Suppression: required")
	}
	type Plain Suppression
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Guid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.Guid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Guid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	*j = Suppression(plain)
	return nil
}

// Describes a sequence of code locations that specify a path through a single
// thread of execution such as an operating system or fiber.
type ThreadFlow struct {
	// An string that uniquely identifies the threadFlow within the codeFlow in which
	// it occurs.
	ID *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Values of relevant expressions at the start of the thread flow that remain
	// constant.
	ImmutableState map[string]MultiformatMessageString `json:"immutableState,omitempty" yaml:"immutableState,omitempty" mapstructure:"immutableState,omitempty"`

	// Values of relevant expressions at the start of the thread flow that may change
	// during thread flow execution.
	InitialState map[string]MultiformatMessageString `json:"initialState,omitempty" yaml:"initialState,omitempty" mapstructure:"initialState,omitempty"`

	// A temporally ordered array of 'threadFlowLocation' objects, each of which
	// describes a location visited by the tool while producing the result.
	Locations []ThreadFlowLocation `json:"locations" yaml:"locations" mapstructure:"locations"`

	// A message relevant to the thread flow.
	Message Message `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// Key/value pairs that provide additional information about the thread flow.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// A location visited by an analysis tool while simulating or monitoring the
// execution of a program.
type ThreadFlowLocation struct {
	// An integer representing the temporal order in which execution reached this
	// location.
	ExecutionOrder int `json:"executionOrder,omitempty" yaml:"executionOrder,omitempty" mapstructure:"executionOrder,omitempty"`

	// The Coordinated Universal Time (UTC) date and time at which this location was
	// executed.
	ExecutionTimeUtc *time.Time `json:"executionTimeUtc,omitempty" yaml:"executionTimeUtc,omitempty" mapstructure:"executionTimeUtc,omitempty"`

	// Specifies the importance of this location in understanding the code flow in
	// which it occurs. The order from most to least important is "essential",
	// "important", "unimportant". Default: "important".
	Importance ThreadFlowLocationImportance `json:"importance,omitempty" yaml:"importance,omitempty" mapstructure:"importance,omitempty"`

	// The index within the run threadFlowLocations array.
	Index int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// A set of distinct strings that categorize the thread flow location. Well-known
	// kinds include 'acquire', 'release', 'enter', 'exit', 'call', 'return',
	// 'branch', 'implicit', 'false', 'true', 'caution', 'danger', 'unknown',
	// 'unreachable', 'taint', 'function', 'handler', 'lock', 'memory', 'resource',
	// 'scope' and 'value'.
	Kinds []string `json:"kinds,omitempty" yaml:"kinds,omitempty" mapstructure:"kinds,omitempty"`

	// The code location.
	Location *Location `json:"location,omitempty" yaml:"location,omitempty" mapstructure:"location,omitempty"`

	// The name of the module that contains the code that is executing.
	Module *string `json:"module,omitempty" yaml:"module,omitempty" mapstructure:"module,omitempty"`

	// An integer representing a containment hierarchy within the thread flow.
	NestingLevel *int `json:"nestingLevel,omitempty" yaml:"nestingLevel,omitempty" mapstructure:"nestingLevel,omitempty"`

	// Key/value pairs that provide additional information about the threadflow
	// location.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The call stack leading to this location.
	Stack *Stack `json:"stack,omitempty" yaml:"stack,omitempty" mapstructure:"stack,omitempty"`

	// A dictionary, each of whose keys specifies a variable or expression, the
	// associated value of which represents the variable or expression value. For an
	// annotation of kind 'continuation', for example, this dictionary might hold the
	// current assumed values of a set of global variables.
	State map[string]MultiformatMessageString `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// An array of references to rule or taxonomy reporting descriptors that are
	// applicable to the thread flow location.
	Taxa []ReportingDescriptorReference `json:"taxa,omitempty" yaml:"taxa,omitempty" mapstructure:"taxa,omitempty"`

	// A web request associated with this thread flow location.
	WebRequest *WebRequest `json:"webRequest,omitempty" yaml:"webRequest,omitempty" mapstructure:"webRequest,omitempty"`

	// A web response associated with this thread flow location.
	WebResponse *WebResponse `json:"webResponse,omitempty" yaml:"webResponse,omitempty" mapstructure:"webResponse,omitempty"`
}

type ThreadFlowLocationImportance string

const ThreadFlowLocationImportanceEssential ThreadFlowLocationImportance = "essential"
const ThreadFlowLocationImportanceImportant ThreadFlowLocationImportance = "important"
const ThreadFlowLocationImportanceUnimportant ThreadFlowLocationImportance = "unimportant"

var enumValues_ThreadFlowLocationImportance = []interface{}{
	"important",
	"essential",
	"unimportant",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreadFlowLocationImportance) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ThreadFlowLocationImportance {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ThreadFlowLocationImportance, v)
	}
	*j = ThreadFlowLocationImportance(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreadFlowLocation) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain ThreadFlowLocation
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["executionOrder"]; !ok || v == nil {
		plain.ExecutionOrder = -1.0
	}
	if -1 > plain.ExecutionOrder {
		return fmt.Errorf("field %s: must be >= %v", "executionOrder", -1)
	}
	if v, ok := raw["importance"]; !ok || v == nil {
		plain.Importance = "important"
	}
	if v, ok := raw["index"]; !ok || v == nil {
		plain.Index = -1.0
	}
	if -1 > plain.Index {
		return fmt.Errorf("field %s: must be >= %v", "index", -1)
	}
	if v, ok := raw["kinds"]; !ok || v == nil {
		plain.Kinds = []string{}
	}
	if plain.NestingLevel != nil && 0 > *plain.NestingLevel {
		return fmt.Errorf("field %s: must be >= %v", "nestingLevel", 0)
	}
	if v, ok := raw["taxa"]; !ok || v == nil {
		plain.Taxa = []ReportingDescriptorReference{}
	}
	*j = ThreadFlowLocation(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ThreadFlow) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["locations"]; raw != nil && !ok {
		return fmt.Errorf("field locations in ThreadFlow: required")
	}
	type Plain ThreadFlow
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Locations != nil && len(plain.Locations) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "locations", 1)
	}
	*j = ThreadFlow(plain)
	return nil
}

// The analysis tool that was run.
type Tool struct {
	// The analysis tool that was run.
	Driver ToolComponent `json:"driver" yaml:"driver" mapstructure:"driver"`

	// Tool extensions that contributed to or reconfigured the analysis tool that was
	// run.
	Extensions []ToolComponent `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// Key/value pairs that provide additional information about the tool.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// A component, such as a plug-in or the driver, of the analysis tool that was run.
type ToolComponent struct {
	// The component which is strongly associated with this component. For a
	// translation, this refers to the component which has been translated. For an
	// extension, this is the driver that provides the extension's plugin model.
	AssociatedComponent *ToolComponentReference `json:"associatedComponent,omitempty" yaml:"associatedComponent,omitempty" mapstructure:"associatedComponent,omitempty"`

	// The kinds of data contained in this object.
	Contents []ToolComponentContentsElem `json:"contents,omitempty" yaml:"contents,omitempty" mapstructure:"contents,omitempty"`

	// The binary version of the tool component's primary executable file expressed as
	// four non-negative integers separated by a period (for operating systems that
	// express file versions in this way).
	DottedQuadFileVersion *string `json:"dottedQuadFileVersion,omitempty" yaml:"dottedQuadFileVersion,omitempty" mapstructure:"dottedQuadFileVersion,omitempty"`

	// The absolute URI from which the tool component can be downloaded.
	DownloadURI *string `json:"downloadURI,omitempty" yaml:"downloadURI,omitempty" mapstructure:"downloadURI,omitempty"`

	// A comprehensive description of the tool component.
	FullDescription *MultiformatMessageString `json:"fullDescription,omitempty" yaml:"fullDescription,omitempty" mapstructure:"fullDescription,omitempty"`

	// The name of the tool component along with its version and any other useful
	// identifying information, such as its locale.
	FullName *string `json:"fullName,omitempty" yaml:"fullName,omitempty" mapstructure:"fullName,omitempty"`

	// A dictionary, each of whose keys is a resource identifier and each of whose
	// values is a multiformatMessageString object, which holds message strings in
	// plain text and (optionally) Markdown format. The strings can include
	// placeholders, which can be used to construct a message in combination with an
	// arbitrary number of additional string arguments.
	GlobalMessageStrings map[string]MultiformatMessageString `json:"globalMessageStrings,omitempty" yaml:"globalMessageStrings,omitempty" mapstructure:"globalMessageStrings,omitempty"`

	// A unique identifier for the tool component in the form of a GUID.
	Guid *string `json:"guid,omitempty" yaml:"guid,omitempty" mapstructure:"guid,omitempty"`

	// The absolute URI at which information about this version of the tool component
	// can be found.
	InformationURI *string `json:"informationURI,omitempty" yaml:"informationURI,omitempty" mapstructure:"informationURI,omitempty"`

	// Specifies whether this object contains a complete definition of the localizable
	// and/or non-localizable data for this component, as opposed to including only
	// data that is relevant to the results persisted to this log file.
	IsComprehensive bool `json:"isComprehensive,omitempty" yaml:"isComprehensive,omitempty" mapstructure:"isComprehensive,omitempty"`

	// The language of the messages emitted into the log file during this run
	// (expressed as an ISO 639-1 two-letter lowercase language code) and an optional
	// region (expressed as an ISO 3166-1 two-letter uppercase subculture code
	// associated with a country or region). The casing is recommended but not
	// required (in order for this data to conform to RFC5646).
	Language string `json:"language,omitempty" yaml:"language,omitempty" mapstructure:"language,omitempty"`

	// The semantic version of the localized strings defined in this component;
	// maintained by components that provide translations.
	LocalizedDataSemanticVersion *string `json:"localizedDataSemanticVersion,omitempty" yaml:"localizedDataSemanticVersion,omitempty" mapstructure:"localizedDataSemanticVersion,omitempty"`

	// An array of the artifactLocation objects associated with the tool component.
	Locations []ArtifactLocation `json:"locations,omitempty" yaml:"locations,omitempty" mapstructure:"locations,omitempty"`

	// The minimum value of localizedDataSemanticVersion required in translations
	// consumed by this component; used by components that consume translations.
	MinimumRequiredLocalizedDataSemanticVersion *string `json:"minimumRequiredLocalizedDataSemanticVersion,omitempty" yaml:"minimumRequiredLocalizedDataSemanticVersion,omitempty" mapstructure:"minimumRequiredLocalizedDataSemanticVersion,omitempty"`

	// The name of the tool component.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// An array of reportingDescriptor objects relevant to the notifications related
	// to the configuration and runtime execution of the tool component.
	Notifications []ReportingDescriptor `json:"notifications,omitempty" yaml:"notifications,omitempty" mapstructure:"notifications,omitempty"`

	// The organization or company that produced the tool component.
	Organization *string `json:"organization,omitempty" yaml:"organization,omitempty" mapstructure:"organization,omitempty"`

	// A product suite to which the tool component belongs.
	Product *string `json:"product,omitempty" yaml:"product,omitempty" mapstructure:"product,omitempty"`

	// A localizable string containing the name of the suite of products to which the
	// tool component belongs.
	ProductSuite *string `json:"productSuite,omitempty" yaml:"productSuite,omitempty" mapstructure:"productSuite,omitempty"`

	// Key/value pairs that provide additional information about the tool component.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A string specifying the UTC date (and optionally, the time) of the component's
	// release.
	ReleaseDateUtc *string `json:"releaseDateUtc,omitempty" yaml:"releaseDateUtc,omitempty" mapstructure:"releaseDateUtc,omitempty"`

	// An array of reportingDescriptor objects relevant to the analysis performed by
	// the tool component.
	Rules []ReportingDescriptor `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// The tool component version in the format specified by Semantic Versioning 2.0.
	SemanticVersion *string `json:"semanticVersion,omitempty" yaml:"semanticVersion,omitempty" mapstructure:"semanticVersion,omitempty"`

	// A brief description of the tool component.
	ShortDescription *MultiformatMessageString `json:"shortDescription,omitempty" yaml:"shortDescription,omitempty" mapstructure:"shortDescription,omitempty"`

	// An array of toolComponentReference objects to declare the taxonomies supported
	// by the tool component.
	SupportedTaxonomies []ToolComponentReference `json:"supportedTaxonomies,omitempty" yaml:"supportedTaxonomies,omitempty" mapstructure:"supportedTaxonomies,omitempty"`

	// An array of reportingDescriptor objects relevant to the definitions of both
	// standalone and tool-defined taxonomies.
	Taxa []ReportingDescriptor `json:"taxa,omitempty" yaml:"taxa,omitempty" mapstructure:"taxa,omitempty"`

	// Translation metadata, required for a translation, not populated by other
	// component types.
	TranslationMetadata *TranslationMetadata `json:"translationMetadata,omitempty" yaml:"translationMetadata,omitempty" mapstructure:"translationMetadata,omitempty"`

	// The tool component version, in whatever format the component natively provides.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

type ToolComponentContentsElem string

const ToolComponentContentsElemLocalizedData ToolComponentContentsElem = "localizedData"
const ToolComponentContentsElemNonLocalizedData ToolComponentContentsElem = "nonLocalizedData"

var enumValues_ToolComponentContentsElem = []interface{}{
	"localizedData",
	"nonLocalizedData",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolComponentContentsElem) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ToolComponentContentsElem {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ToolComponentContentsElem, v)
	}
	*j = ToolComponentContentsElem(v)
	return nil
}

// IDentifies a particular toolComponent object, either the driver or an extension.
type ToolComponentReference struct {
	// The 'guid' property of the referenced toolComponent.
	Guid *string `json:"guid,omitempty" yaml:"guid,omitempty" mapstructure:"guid,omitempty"`

	// An index into the referenced toolComponent in tool.extensions.
	Index int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// The 'name' property of the referenced toolComponent.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Key/value pairs that provide additional information about the
	// toolComponentReference.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolComponentReference) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain ToolComponentReference
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Guid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.Guid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Guid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["index"]; !ok || v == nil {
		plain.Index = -1.0
	}
	if -1 > plain.Index {
		return fmt.Errorf("field %s: must be >= %v", "index", -1)
	}
	*j = ToolComponentReference(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ToolComponent) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in ToolComponent: required")
	}
	type Plain ToolComponent
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["contents"]; !ok || v == nil {
		plain.Contents = []ToolComponentContentsElem{
			"localizedData",
			"nonLocalizedData",
		}
	}
	if plain.DottedQuadFileVersion != nil {
		if matched, _ := regexp.MatchString(`[0-9]+(\.[0-9]+){3}`, string(*plain.DottedQuadFileVersion)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "DottedQuadFileVersion", `[0-9]+(\.[0-9]+){3}`)
		}
	}
	if plain.Guid != nil {
		if matched, _ := regexp.MatchString(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`, string(*plain.Guid)); !matched {
			return fmt.Errorf("field %s pattern match: must match %s", "Guid", `^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$`)
		}
	}
	if v, ok := raw["isComprehensive"]; !ok || v == nil {
		plain.IsComprehensive = false
	}
	if v, ok := raw["language"]; !ok || v == nil {
		plain.Language = "en-US"
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z]{2}(-[a-zA-Z]{2})?$`, string(plain.Language)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Language", `^[a-zA-Z]{2}(-[a-zA-Z]{2})?$`)
	}
	if v, ok := raw["locations"]; !ok || v == nil {
		plain.Locations = []ArtifactLocation{}
	}
	if v, ok := raw["notifications"]; !ok || v == nil {
		plain.Notifications = []ReportingDescriptor{}
	}
	if v, ok := raw["rules"]; !ok || v == nil {
		plain.Rules = []ReportingDescriptor{}
	}
	if v, ok := raw["supportedTaxonomies"]; !ok || v == nil {
		plain.SupportedTaxonomies = []ToolComponentReference{}
	}
	if v, ok := raw["taxa"]; !ok || v == nil {
		plain.Taxa = []ReportingDescriptor{}
	}
	*j = ToolComponent(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tool) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["driver"]; raw != nil && !ok {
		return fmt.Errorf("field driver in Tool: required")
	}
	type Plain Tool
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["extensions"]; !ok || v == nil {
		plain.Extensions = []ToolComponent{}
	}
	*j = Tool(plain)
	return nil
}

// Provides additional metadata related to translation.
type TranslationMetadata struct {
	// The absolute URI from which the translation metadata can be downloaded.
	DownloadURI *string `json:"downloadURI,omitempty" yaml:"downloadURI,omitempty" mapstructure:"downloadURI,omitempty"`

	// A comprehensive description of the translation metadata.
	FullDescription *MultiformatMessageString `json:"fullDescription,omitempty" yaml:"fullDescription,omitempty" mapstructure:"fullDescription,omitempty"`

	// The full name associated with the translation metadata.
	FullName *string `json:"fullName,omitempty" yaml:"fullName,omitempty" mapstructure:"fullName,omitempty"`

	// The absolute URI from which information related to the translation metadata can
	// be downloaded.
	InformationURI *string `json:"informationURI,omitempty" yaml:"informationURI,omitempty" mapstructure:"informationURI,omitempty"`

	// The name associated with the translation metadata.
	Name string `json:"name" yaml:"name" mapstructure:"name"`

	// Key/value pairs that provide additional information about the translation
	// metadata.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// A brief description of the translation metadata.
	ShortDescription *MultiformatMessageString `json:"shortDescription,omitempty" yaml:"shortDescription,omitempty" mapstructure:"shortDescription,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TranslationMetadata) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["name"]; raw != nil && !ok {
		return fmt.Errorf("field name in TranslationMetadata: required")
	}
	type Plain TranslationMetadata
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = TranslationMetadata(plain)
	return nil
}

// Specifies the information necessary to retrieve a desired revision from a
// version control system.
type VersionControlDetails struct {
	// A Coordinated Universal Time (UTC) date and time that can be used to
	// synchronize an enlistment to the state of the repository at that time.
	AsOfTimeUtc *time.Time `json:"asOfTimeUtc,omitempty" yaml:"asOfTimeUtc,omitempty" mapstructure:"asOfTimeUtc,omitempty"`

	// The name of a branch containing the revision.
	Branch *string `json:"branch,omitempty" yaml:"branch,omitempty" mapstructure:"branch,omitempty"`

	// The location in the local file system to which the root of the repository was
	// mapped at the time of the analysis.
	MappedTo *ArtifactLocation `json:"mappedTo,omitempty" yaml:"mappedTo,omitempty" mapstructure:"mappedTo,omitempty"`

	// Key/value pairs that provide additional information about the version control
	// details.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The absolute URI of the repository.
	RepositoryURI string `json:"repositoryURI" yaml:"repositoryURI" mapstructure:"repositoryURI"`

	// A string that uniquely and permanently identifies the revision within the
	// repository.
	RevisionID *string `json:"revisionID,omitempty" yaml:"revisionID,omitempty" mapstructure:"revisionID,omitempty"`

	// A tag that has been applied to the revision.
	RevisionTag *string `json:"revisionTag,omitempty" yaml:"revisionTag,omitempty" mapstructure:"revisionTag,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VersionControlDetails) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["repositoryURI"]; raw != nil && !ok {
		return fmt.Errorf("field repositoryURI in VersionControlDetails: required")
	}
	type Plain VersionControlDetails
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = VersionControlDetails(plain)
	return nil
}

// Describes an HTTP request.
type WebRequest struct {
	// The body of the request.
	Body *ArtifactContent `json:"body,omitempty" yaml:"body,omitempty" mapstructure:"body,omitempty"`

	// The request headers.
	Headers map[string]string `json:"headers,omitempty" yaml:"headers,omitempty" mapstructure:"headers,omitempty"`

	// The index within the run.webRequests array of the request object associated
	// with this result.
	Index int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH',
	// 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.
	Method *string `json:"method,omitempty" yaml:"method,omitempty" mapstructure:"method,omitempty"`

	// The request parameters.
	Parameters map[string]string `json:"parameters,omitempty" yaml:"parameters,omitempty" mapstructure:"parameters,omitempty"`

	// Key/value pairs that provide additional information about the request.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The request protocol. Example: 'http'.
	Protocol *string `json:"protocol,omitempty" yaml:"protocol,omitempty" mapstructure:"protocol,omitempty"`

	// The target of the request.
	Target *string `json:"target,omitempty" yaml:"target,omitempty" mapstructure:"target,omitempty"`

	// The request version. Example: '1.1'.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebRequest) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain WebRequest
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		plain.Index = -1.0
	}
	if -1 > plain.Index {
		return fmt.Errorf("field %s: must be >= %v", "index", -1)
	}
	*j = WebRequest(plain)
	return nil
}

// Describes the response to an HTTP request.
type WebResponse struct {
	// The body of the response.
	Body *ArtifactContent `json:"body,omitempty" yaml:"body,omitempty" mapstructure:"body,omitempty"`

	// The response headers.
	Headers map[string]string `json:"headers,omitempty" yaml:"headers,omitempty" mapstructure:"headers,omitempty"`

	// The index within the run.webResponses array of the response object associated
	// with this result.
	Index int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// Specifies whether a response was received from the server.
	NoResponseReceived bool `json:"noResponseReceived,omitempty" yaml:"noResponseReceived,omitempty" mapstructure:"noResponseReceived,omitempty"`

	// Key/value pairs that provide additional information about the response.
	Properties *PropertyBag `json:"properties,omitempty" yaml:"properties,omitempty" mapstructure:"properties,omitempty"`

	// The response protocol. Example: 'http'.
	Protocol *string `json:"protocol,omitempty" yaml:"protocol,omitempty" mapstructure:"protocol,omitempty"`

	// The response reason. Example: 'Not found'.
	ReasonPhrase *string `json:"reasonPhrase,omitempty" yaml:"reasonPhrase,omitempty" mapstructure:"reasonPhrase,omitempty"`

	// The response status code. Example: 451.
	StatusCode *int `json:"statusCode,omitempty" yaml:"statusCode,omitempty" mapstructure:"statusCode,omitempty"`

	// The response version. Example: '1.1'.
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WebResponse) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain WebResponse
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["index"]; !ok || v == nil {
		plain.Index = -1.0
	}
	if -1 > plain.Index {
		return fmt.Errorf("field %s: must be >= %v", "index", -1)
	}
	if v, ok := raw["noResponseReceived"]; !ok || v == nil {
		plain.NoResponseReceived = false
	}
	*j = WebResponse(plain)
	return nil
}
